<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RT-Thread RTOS: Thread Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtthread_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RT-Thread RTOS
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">An open source embedded real-time operating system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___thread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread Management<div class="ingroups"><a class="el" href="group___kernel.html">RT-Thread Kernel API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Thread Management:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="group___thread.png" border="0" usemap="#agroup______thread" alt=""/></div>
<map name="agroup______thread" id="agroup______thread">
<area shape="rect" href="group___kernel.html" title=" " alt="" coords="5,5,161,31"/>
<area shape="rect" title="the thread management" alt="" coords="209,5,367,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__cpu__usage__stats.html">rt_cpu_usage_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__thread.html">rt_thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae743a0f57a34ce46c0687ff787972ded"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gae743a0f57a34ce46c0687ff787972ded">RT_THREAD_INIT</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gae743a0f57a34ce46c0687ff787972ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c39773ce3aefe35d15e68f34ddedc9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga1c39773ce3aefe35d15e68f34ddedc9a">RT_THREAD_CLOSE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga1c39773ce3aefe35d15e68f34ddedc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2482a36a666c7e796f0fee67c0d3f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga3d2482a36a666c7e796f0fee67c0d3f3">RT_THREAD_READY</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga3d2482a36a666c7e796f0fee67c0d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76fc51507d2201f644b94b916560778b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga76fc51507d2201f644b94b916560778b">RT_THREAD_RUNNING</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:ga76fc51507d2201f644b94b916560778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52105c3a810895c9c9103064b9be1141"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga52105c3a810895c9c9103064b9be1141">RT_THREAD_SUSPEND_INTERRUPTIBLE</a>&#160;&#160;&#160;(RT_THREAD_SUSPEND_MASK)</td></tr>
<tr class="separator:ga52105c3a810895c9c9103064b9be1141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740d81278ba15e5a8ed943a2b9d5fe79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga740d81278ba15e5a8ed943a2b9d5fe79">RT_THREAD_SUSPEND_KILLABLE</a>&#160;&#160;&#160;(RT_THREAD_SUSPEND_MASK | RT_SIGNAL_COMMON_WAKEUP_MASK)</td></tr>
<tr class="separator:ga740d81278ba15e5a8ed943a2b9d5fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee5f39c3bc12f74abdb1a513a853133"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga6ee5f39c3bc12f74abdb1a513a853133">RT_THREAD_SUSPEND_UNINTERRUPTIBLE</a>&#160;&#160;&#160;(RT_THREAD_SUSPEND_MASK | RT_SIGNAL_COMMON_WAKEUP_MASK | RT_SIGNAL_KILL_WAKEUP_MASK)</td></tr>
<tr class="separator:ga6ee5f39c3bc12f74abdb1a513a853133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f8bae7391260aaaa55256c41ebf07c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga8f8bae7391260aaaa55256c41ebf07c1">RT_THREAD_STAT_YIELD</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga8f8bae7391260aaaa55256c41ebf07c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb3ce12c6600fa83a4cd66e8b86ce35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gafcb3ce12c6600fa83a4cd66e8b86ce35">RT_THREAD_STAT_SIGNAL</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gafcb3ce12c6600fa83a4cd66e8b86ce35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fff76fd7571a9684f61a718e66cb104"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga4fff76fd7571a9684f61a718e66cb104">RT_THREAD_STAT_SIGNAL_WAIT</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ga4fff76fd7571a9684f61a718e66cb104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e5d5ab9fb99840ad871e6092335d7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gaa3e5d5ab9fb99840ad871e6092335d7a">RT_THREAD_STAT_SIGNAL_PENDING</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:gaa3e5d5ab9fb99840ad871e6092335d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94f55354bd0e145bd855bd38db5c442"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gae94f55354bd0e145bd855bd38db5c442">RT_THREAD_CTRL_STARTUP</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gae94f55354bd0e145bd855bd38db5c442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad875eaaa2400aef8f6078f5d1f8297b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gad875eaaa2400aef8f6078f5d1f8297b3">RT_THREAD_CTRL_CLOSE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:gad875eaaa2400aef8f6078f5d1f8297b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59e5c8ec96f8b3231947b0c665e5fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gad59e5c8ec96f8b3231947b0c665e5fba">RT_THREAD_CTRL_CHANGE_PRIORITY</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gad59e5c8ec96f8b3231947b0c665e5fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ba1445796c920c2ae943b419e19d4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga45ba1445796c920c2ae943b419e19d4b">RT_THREAD_CTRL_INFO</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:ga45ba1445796c920c2ae943b419e19d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e2bf49443c5a96c293a554203de8e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga33e2bf49443c5a96c293a554203de8e3">RT_THREAD_CTRL_BIND_CPU</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga33e2bf49443c5a96c293a554203de8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7834be0d0c62aaa32ae47ade3ac21e68"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga7834be0d0c62aaa32ae47ade3ac21e68">rt_thread_inited_hookproto_t</a>) (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga7834be0d0c62aaa32ae47ade3ac21e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacd985aa60939b95e510f144610f001b9"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gacd985aa60939b95e510f144610f001b9">rt_thread_init</a> (struct <a class="el" href="structrt__thread.html">rt_thread</a> *thread, const char *name, void(*entry)(void *parameter), void *parameter, void *stack_start, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick)</td></tr>
<tr class="separator:gacd985aa60939b95e510f144610f001b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6133c1b6b27d972447156db15e7c1ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga6133c1b6b27d972447156db15e7c1ce7">rt_thread_self</a> (void)</td></tr>
<tr class="separator:ga6133c1b6b27d972447156db15e7c1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b743537fd099e204fc292e57b4aa5a"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga04b743537fd099e204fc292e57b4aa5a">rt_thread_startup</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga04b743537fd099e204fc292e57b4aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c482e895baff359b920966f2822ee06"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga0c482e895baff359b920966f2822ee06">rt_thread_close</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga0c482e895baff359b920966f2822ee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514825b80304477ecf377d721da409b0"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga514825b80304477ecf377d721da409b0">rt_thread_detach</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga514825b80304477ecf377d721da409b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb215b161f17c26b5e19c28cd0119e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gacb215b161f17c26b5e19c28cd0119e7b">rt_thread_create</a> (const char *name, void(*entry)(void *parameter), void *parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick)</td></tr>
<tr class="separator:gacb215b161f17c26b5e19c28cd0119e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d64eb4d0a485461049616808f4ce177"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga6d64eb4d0a485461049616808f4ce177">rt_thread_delete</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga6d64eb4d0a485461049616808f4ce177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5703a0d7351b37a1c00874a362626ea3"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga5703a0d7351b37a1c00874a362626ea3">rt_thread_yield</a> (void)</td></tr>
<tr class="separator:ga5703a0d7351b37a1c00874a362626ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b18459cac67e3695447e69b997fc74e"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga6b18459cac67e3695447e69b997fc74e">rt_thread_delay</a> (rt_tick_t tick)</td></tr>
<tr class="separator:ga6b18459cac67e3695447e69b997fc74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309d01453eb09acaee5012a2e159961c"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga309d01453eb09acaee5012a2e159961c">rt_thread_delay_until</a> (rt_tick_t *tick, rt_tick_t inc_tick)</td></tr>
<tr class="separator:ga309d01453eb09acaee5012a2e159961c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba0dbf06d5fa05f469da371ff6d2876"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga4ba0dbf06d5fa05f469da371ff6d2876">rt_thread_mdelay</a> (rt_int32_t ms)</td></tr>
<tr class="separator:ga4ba0dbf06d5fa05f469da371ff6d2876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c65d3f7d01310fe7b54b2e706b1bdc"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga34c65d3f7d01310fe7b54b2e706b1bdc">rt_thread_control</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread, int cmd, void *arg)</td></tr>
<tr class="separator:ga34c65d3f7d01310fe7b54b2e706b1bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e560062d5e4b929ad2868e4ccc90f2"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga41e560062d5e4b929ad2868e4ccc90f2">rt_thread_suspend_to_list</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread, <a class="el" href="structrt__list__node.html">rt_list_t</a> *susp_list, int ipc_flags, int suspend_flag)</td></tr>
<tr class="separator:ga41e560062d5e4b929ad2868e4ccc90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537adfa695f87cdea6310ec3f66fced0"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga537adfa695f87cdea6310ec3f66fced0">rt_thread_suspend_with_flag</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread, int suspend_flag)</td></tr>
<tr class="separator:ga537adfa695f87cdea6310ec3f66fced0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f29aff4fec96d92f6321fa7b00c379"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gab4f29aff4fec96d92f6321fa7b00c379">rt_thread_resume</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:gab4f29aff4fec96d92f6321fa7b00c379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga789a0782597b4d7f7c6c16eacc6084a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga789a0782597b4d7f7c6c16eacc6084a8">rt_thread_find</a> (char *name)</td></tr>
<tr class="separator:ga789a0782597b4d7f7c6c16eacc6084a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2474c7ee1c6eb90f676ecbbc904363"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga0e2474c7ee1c6eb90f676ecbbc904363">rt_thread_get_name</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread, char *name, rt_uint8_t name_size)</td></tr>
<tr class="separator:ga0e2474c7ee1c6eb90f676ecbbc904363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0dcacf89c3d97272b185f7162a3e0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gae0dcacf89c3d97272b185f7162a3e0c3">rt_thread_idle_init</a> (void)</td></tr>
<tr class="separator:gae0dcacf89c3d97272b185f7162a3e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48521904309636f9ccdbf562199c0a5"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gaf48521904309636f9ccdbf562199c0a5">rt_thread_idle_delhook</a> (void(*hook)(void))</td></tr>
<tr class="separator:gaf48521904309636f9ccdbf562199c0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd22f9965fffe9e940fd364f0838731f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gadd22f9965fffe9e940fd364f0838731f">rt_thread_idle_gethandler</a> (void)</td></tr>
<tr class="separator:gadd22f9965fffe9e940fd364f0838731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa2c0c67999e20ce8693ad3c8e624f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga5aa2c0c67999e20ce8693ad3c8e624f0">rt_system_scheduler_init</a> (void)</td></tr>
<tr class="separator:ga5aa2c0c67999e20ce8693ad3c8e624f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa8a561e0caf5e13126834c4f4bb681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga9aa8a561e0caf5e13126834c4f4bb681">rt_system_scheduler_start</a> (void)</td></tr>
<tr class="separator:ga9aa8a561e0caf5e13126834c4f4bb681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f99bb5e2e2032b10ddda7a03eefe24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gae9f99bb5e2e2032b10ddda7a03eefe24">rt_schedule</a> (void)</td></tr>
<tr class="separator:gae9f99bb5e2e2032b10ddda7a03eefe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4158a39c5ea956a96b22190ce0ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gabb4158a39c5ea956a96b22190ce0ed89">rt_scheduler_do_irq_switch</a> (void *context)</td></tr>
<tr class="separator:gabb4158a39c5ea956a96b22190ce0ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c796a7c2031213d9d2416c6e4a5b6a"><td class="memItemLeft" align="right" valign="top">rt_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gac4c796a7c2031213d9d2416c6e4a5b6a">rt_enter_critical</a> (void)</td></tr>
<tr class="separator:gac4c796a7c2031213d9d2416c6e4a5b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c56c2d56e2bb0f2df95abc752143df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga35c56c2d56e2bb0f2df95abc752143df">rt_exit_critical</a> (void)</td></tr>
<tr class="separator:ga35c56c2d56e2bb0f2df95abc752143df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f894e8efadefda238a5e5ab45c7e21"><td class="memItemLeft" align="right" valign="top">rt_uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gaf3f894e8efadefda238a5e5ab45c7e21">rt_critical_level</a> (void)</td></tr>
<tr class="separator:gaf3f894e8efadefda238a5e5ab45c7e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268d9fc914d7f4b144568e5de5049b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga268d9fc914d7f4b144568e5de5049b63">rt_scheduler_ipi_handler</a> (int vector, void *param)</td></tr>
<tr class="separator:ga268d9fc914d7f4b144568e5de5049b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b532499fffe26f36b7ed8b9e3e4654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#gae3b532499fffe26f36b7ed8b9e3e4654">rt_schedule_insert_thread</a> (struct <a class="el" href="structrt__thread.html">rt_thread</a> *thread)</td></tr>
<tr class="separator:gae3b532499fffe26f36b7ed8b9e3e4654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11893d937cb7c879abb12f8bfa4be164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___thread.html#ga11893d937cb7c879abb12f8bfa4be164">rt_schedule_remove_thread</a> (struct <a class="el" href="structrt__thread.html">rt_thread</a> *thread)</td></tr>
<tr class="separator:ga11893d937cb7c879abb12f8bfa4be164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>the thread management </p>
<p>RT-Thread operating system supports multitask systems, which are based on thread scheduling.</p><ul>
<li>The scheduling is a full preemptive priority-based scheduling algorithm.</li>
<li>8/32/256 priority levels are supported, in which 0 is the highest and 7/31/255 the lowest. The 7/31/255th priority is used for idle thread.</li>
<li>Threads running at same priority level are supported. The shared time-slice round-robin scheduling is used for this case.</li>
<li>The time of scheduler to choose the next highest ready thread is determinant.</li>
<li>There are four status in thread management<ol type="1">
<li>Initialization</li>
<li>Running/Ready</li>
<li>Blocked</li>
<li>Closed</li>
</ol>
</li>
<li>The number of threads in the system is unlimited, only related with RAM. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae743a0f57a34ce46c0687ff787972ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae743a0f57a34ce46c0687ff787972ded">&#9670;&nbsp;</a></span>RT_THREAD_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_INIT&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialized status </p>

</div>
</div>
<a id="ga1c39773ce3aefe35d15e68f34ddedc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c39773ce3aefe35d15e68f34ddedc9a">&#9670;&nbsp;</a></span>RT_THREAD_CLOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_CLOSE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closed status </p>

</div>
</div>
<a id="ga3d2482a36a666c7e796f0fee67c0d3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2482a36a666c7e796f0fee67c0d3f3">&#9670;&nbsp;</a></span>RT_THREAD_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_READY&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ready status </p>

</div>
</div>
<a id="ga76fc51507d2201f644b94b916560778b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76fc51507d2201f644b94b916560778b">&#9670;&nbsp;</a></span>RT_THREAD_RUNNING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_RUNNING&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Running status </p>

</div>
</div>
<a id="ga52105c3a810895c9c9103064b9be1141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52105c3a810895c9c9103064b9be1141">&#9670;&nbsp;</a></span>RT_THREAD_SUSPEND_INTERRUPTIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_SUSPEND_INTERRUPTIBLE&#160;&#160;&#160;(RT_THREAD_SUSPEND_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend interruptable 0x4 </p>

</div>
</div>
<a id="ga740d81278ba15e5a8ed943a2b9d5fe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga740d81278ba15e5a8ed943a2b9d5fe79">&#9670;&nbsp;</a></span>RT_THREAD_SUSPEND_KILLABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_SUSPEND_KILLABLE&#160;&#160;&#160;(RT_THREAD_SUSPEND_MASK | RT_SIGNAL_COMMON_WAKEUP_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend with killable 0x6 </p>

</div>
</div>
<a id="ga6ee5f39c3bc12f74abdb1a513a853133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee5f39c3bc12f74abdb1a513a853133">&#9670;&nbsp;</a></span>RT_THREAD_SUSPEND_UNINTERRUPTIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_SUSPEND_UNINTERRUPTIBLE&#160;&#160;&#160;(RT_THREAD_SUSPEND_MASK | RT_SIGNAL_COMMON_WAKEUP_MASK | RT_SIGNAL_KILL_WAKEUP_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend with uninterruptable 0x7 </p>

</div>
</div>
<a id="ga8f8bae7391260aaaa55256c41ebf07c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f8bae7391260aaaa55256c41ebf07c1">&#9670;&nbsp;</a></span>RT_THREAD_STAT_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_STAT_YIELD&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicate whether remaining_tick has been reloaded since last schedule </p>

</div>
</div>
<a id="gafcb3ce12c6600fa83a4cd66e8b86ce35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcb3ce12c6600fa83a4cd66e8b86ce35">&#9670;&nbsp;</a></span>RT_THREAD_STAT_SIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_STAT_SIGNAL&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>task hold signals </p>

</div>
</div>
<a id="ga4fff76fd7571a9684f61a718e66cb104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fff76fd7571a9684f61a718e66cb104">&#9670;&nbsp;</a></span>RT_THREAD_STAT_SIGNAL_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_STAT_SIGNAL_WAIT&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>task is waiting for signals </p>

</div>
</div>
<a id="gaa3e5d5ab9fb99840ad871e6092335d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3e5d5ab9fb99840ad871e6092335d7a">&#9670;&nbsp;</a></span>RT_THREAD_STAT_SIGNAL_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_STAT_SIGNAL_PENDING&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>signals is held and it has not been procressed </p>

</div>
</div>
<a id="gae94f55354bd0e145bd855bd38db5c442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94f55354bd0e145bd855bd38db5c442">&#9670;&nbsp;</a></span>RT_THREAD_CTRL_STARTUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_CTRL_STARTUP&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>thread control command definitions Startup thread. </p>

</div>
</div>
<a id="gad875eaaa2400aef8f6078f5d1f8297b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad875eaaa2400aef8f6078f5d1f8297b3">&#9670;&nbsp;</a></span>RT_THREAD_CTRL_CLOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_CTRL_CLOSE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close thread. </p>

</div>
</div>
<a id="gad59e5c8ec96f8b3231947b0c665e5fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59e5c8ec96f8b3231947b0c665e5fba">&#9670;&nbsp;</a></span>RT_THREAD_CTRL_CHANGE_PRIORITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_CTRL_CHANGE_PRIORITY&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change thread priority. </p>

</div>
</div>
<a id="ga45ba1445796c920c2ae943b419e19d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ba1445796c920c2ae943b419e19d4b">&#9670;&nbsp;</a></span>RT_THREAD_CTRL_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_CTRL_INFO&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get thread information. </p>

</div>
</div>
<a id="ga33e2bf49443c5a96c293a554203de8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e2bf49443c5a96c293a554203de8e3">&#9670;&nbsp;</a></span>RT_THREAD_CTRL_BIND_CPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_THREAD_CTRL_BIND_CPU&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set thread bind cpu. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga7834be0d0c62aaa32ae47ade3ac21e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7834be0d0c62aaa32ae47ade3ac21e68">&#9670;&nbsp;</a></span>rt_thread_inited_hookproto_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rt_thread_inited_hookproto_t) (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a hook function when a thread is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the target thread that initializing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacd985aa60939b95e510f144610f001b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd985aa60939b95e510f144610f001b9">&#9670;&nbsp;</a></span>rt_thread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__thread.html">rt_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *parameter)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>tick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize a thread. It's used to initialize a static thread object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the static thread object.</td></tr>
    <tr><td class="paramname">name</td><td>is the name of thread, which shall be unique.</td></tr>
    <tr><td class="paramname">entry</td><td>is the entry function of thread.</td></tr>
    <tr><td class="paramname">parameter</td><td>is the parameter of thread enter function.</td></tr>
    <tr><td class="paramname">stack_start</td><td>is the start address of thread stack.</td></tr>
    <tr><td class="paramname">stack_size</td><td>is the size of thread stack.</td></tr>
    <tr><td class="paramname">priority</td><td>is the priority of thread.</td></tr>
    <tr><td class="paramname">tick</td><td>is the time slice if there are same priority thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga6133c1b6b27d972447156db15e7c1ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6133c1b6b27d972447156db15e7c1ce7">&#9670;&nbsp;</a></span>rt_thread_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__thread.html">rt_thread_t</a> rt_thread_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will return self thread object. </p>
<dl class="section return"><dt>Returns</dt><dd>The self thread object. </dd></dl>

</div>
</div>
<a id="ga04b743537fd099e204fc292e57b4aa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04b743537fd099e204fc292e57b4aa5a">&#9670;&nbsp;</a></span>rt_thread_startup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_startup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will start a thread and put it to system ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga0c482e895baff359b920966f2822ee06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c482e895baff359b920966f2822ee06">&#9670;&nbsp;</a></span>rt_thread_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will close a thread. The thread object will be removed from thread queue and detached/deleted from the system object management. It's different from rt_thread_delete or rt_thread_detach that this will not enqueue the closing thread to cleanup queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga514825b80304477ecf377d721da409b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga514825b80304477ecf377d721da409b0">&#9670;&nbsp;</a></span>rt_thread_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will detach a thread. The thread object will be removed from thread queue and detached/deleted from the system object management. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="gacb215b161f17c26b5e19c28cd0119e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb215b161f17c26b5e19c28cd0119e7b">&#9670;&nbsp;</a></span>rt_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__thread.html">rt_thread_t</a> rt_thread_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *parameter)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>tick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will create a thread object and allocate thread object memory. and stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name of thread, which shall be unique.</td></tr>
    <tr><td class="paramname">entry</td><td>is the entry function of thread.</td></tr>
    <tr><td class="paramname">parameter</td><td>is the parameter of thread enter function.</td></tr>
    <tr><td class="paramname">stack_size</td><td>is the size of thread stack.</td></tr>
    <tr><td class="paramname">priority</td><td>is the priority of thread.</td></tr>
    <tr><td class="paramname">tick</td><td>is the time slice if there are same priority thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the return value is a <a class="el" href="structrt__thread.html">rt_thread</a> structure pointer, the function is successfully executed. If the return value is RT_NULL, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga6d64eb4d0a485461049616808f4ce177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d64eb4d0a485461049616808f4ce177">&#9670;&nbsp;</a></span>rt_thread_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will delete a thread. The thread object will be removed from thread queue and deleted from system object management in the idle thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga5703a0d7351b37a1c00874a362626ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5703a0d7351b37a1c00874a362626ea3">&#9670;&nbsp;</a></span>rt_thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will let current thread yield processor, and scheduler will choose the highest thread to run. After yield processor, the current thread is still in READY state. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga6b18459cac67e3695447e69b997fc74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b18459cac67e3695447e69b997fc74e">&#9670;&nbsp;</a></span>rt_thread_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_delay </td>
          <td>(</td>
          <td class="paramtype">rt_tick_t&#160;</td>
          <td class="paramname"><em>tick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will let current thread delay for some ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>is the delay ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga309d01453eb09acaee5012a2e159961c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga309d01453eb09acaee5012a2e159961c">&#9670;&nbsp;</a></span>rt_thread_delay_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_delay_until </td>
          <td>(</td>
          <td class="paramtype">rt_tick_t *&#160;</td>
          <td class="paramname"><em>tick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_tick_t&#160;</td>
          <td class="paramname"><em>inc_tick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will let current thread delay until (*tick + inc_tick). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>is the tick of last wakeup.</td></tr>
    <tr><td class="paramname">inc_tick</td><td>is the increment tick.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga4ba0dbf06d5fa05f469da371ff6d2876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ba0dbf06d5fa05f469da371ff6d2876">&#9670;&nbsp;</a></span>rt_thread_mdelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_mdelay </td>
          <td>(</td>
          <td class="paramtype">rt_int32_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will let current thread delay for some milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>is the delay ms time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga34c65d3f7d01310fe7b54b2e706b1bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34c65d3f7d01310fe7b54b2e706b1bdc">&#9670;&nbsp;</a></span>rt_thread_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will control thread behaviors according to control command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the specified thread to be controlled.</td></tr>
    <tr><td class="paramname">cmd</td><td>is the control command, which includes. <pre class="fragment">         RT_THREAD_CTRL_CHANGE_PRIORITY for changing priority level of thread.

         RT_THREAD_CTRL_STARTUP for starting a thread.

         RT_THREAD_CTRL_CLOSE for delete a thread.

         RT_THREAD_CTRL_BIND_CPU for bind the thread to a CPU.
</pre> </td></tr>
    <tr><td class="paramname">arg</td><td>is the argument of control command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga41e560062d5e4b929ad2868e4ccc90f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e560062d5e4b929ad2868e4ccc90f2">&#9670;&nbsp;</a></span>rt_thread_suspend_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_suspend_to_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>susp_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ipc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>suspend_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will suspend the specified thread and change it to suspend state. </p>
<dl class="section note"><dt>Note</dt><dd>This function ONLY can suspend current thread itself. rt_thread_suspend(rt_thread_self());</dd></dl>
<p>Do not use the rt_thread_suspend to suspend other threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while sharing a resouce with other threads and occupying this resouce, starvation can occur very easily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to be suspended. </td></tr>
    <tr><td class="paramname">susp_list</td><td>the list thread enqueued to. RT_NULL if no list. </td></tr>
    <tr><td class="paramname">ipc_flags</td><td>is a flag for the thread object to be suspended. It determines how the thread is suspended. The flag can be ONE of the following values: RT_IPC_FLAG_PRIO The pending threads will queue in order of priority. RT_IPC_FLAG_FIFO The pending threads will queue in the first-in-first-out method (also known as first-come-first-served (FCFS) scheduling strategy). NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about the first-in-first-out principle, and you clearly understand that all threads involved in this semaphore will become non-real-time threads. </td></tr>
    <tr><td class="paramname">suspend_flag</td><td>status flag of the thread to be suspended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>
<p>enqueue thread on the push list before leaving critical region of scheduler, so we won't miss notification of async events.</p>

</div>
</div>
<a id="ga537adfa695f87cdea6310ec3f66fced0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga537adfa695f87cdea6310ec3f66fced0">&#9670;&nbsp;</a></span>rt_thread_suspend_with_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_suspend_with_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>suspend_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will suspend the specified thread and change it to suspend state. </p>
<dl class="section note"><dt>Note</dt><dd>This function ONLY can suspend current thread itself. rt_thread_suspend(rt_thread_self());</dd></dl>
<p>Do not use the rt_thread_suspend to suspend other threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while sharing a resouce with other threads and occupying this resouce, starvation can occur very easily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to be suspended. </td></tr>
    <tr><td class="paramname">suspend_flag</td><td>status flag of the thread to be suspended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="gab4f29aff4fec96d92f6321fa7b00c379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f29aff4fec96d92f6321fa7b00c379">&#9670;&nbsp;</a></span>rt_thread_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will resume a thread and put it to system ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be resumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>
<p>RT_ESCHEDLOCKED indicates that the current thread is in a critical section, rather than 'thread' can't be resumed. Therefore, we can ignore this error.</p>

</div>
</div>
<a id="ga789a0782597b4d7f7c6c16eacc6084a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga789a0782597b4d7f7c6c16eacc6084a8">&#9670;&nbsp;</a></span>rt_thread_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__thread.html">rt_thread_t</a> rt_thread_find </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will find the specified thread. </p>
<dl class="section note"><dt>Note</dt><dd>Please don't invoke this function in interrupt status.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name of thread finding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the return value is a <a class="el" href="structrt__thread.html">rt_thread</a> structure pointer, the function is successfully executed. If the return value is RT_NULL, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga0e2474c7ee1c6eb90f676ecbbc904363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e2474c7ee1c6eb90f676ecbbc904363">&#9670;&nbsp;</a></span>rt_thread_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_get_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>name_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will return the name of the specified thread. </p>
<dl class="section note"><dt>Note</dt><dd>Please don't invoke this function in interrupt status</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to retrieve thread name </td></tr>
    <tr><td class="paramname">name</td><td>buffer to store the thread name string </td></tr>
    <tr><td class="paramname">name_size</td><td>maximum size of the buffer to store the thread name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the return value is RT_EOK, the function is successfully executed If the return value is -RT_EINVAL, it means this operation failed </dd></dl>

</div>
</div>
<a id="gae0dcacf89c3d97272b185f7162a3e0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0dcacf89c3d97272b185f7162a3e0c3">&#9670;&nbsp;</a></span>rt_thread_idle_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_thread_idle_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize idle thread, then start it. </p>
<dl class="section note"><dt>Note</dt><dd>this function must be invoked when system init. </dd></dl>

</div>
</div>
<a id="gaf48521904309636f9ccdbf562199c0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf48521904309636f9ccdbf562199c0a5">&#9670;&nbsp;</a></span>rt_thread_idle_delhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_idle_delhook </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete the idle hook on hook list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hook</td><td>the specified hook function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RT_EOK: delete OK. -RT_ENOSYS: hook was not found. </dd></dl>

</div>
</div>
<a id="gadd22f9965fffe9e940fd364f0838731f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd22f9965fffe9e940fd364f0838731f">&#9670;&nbsp;</a></span>rt_thread_idle_gethandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__thread.html">rt_thread_t</a> rt_thread_idle_gethandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will get the handler of the idle thread. </p>

</div>
</div>
<a id="ga5aa2c0c67999e20ce8693ad3c8e624f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aa2c0c67999e20ce8693ad3c8e624f0">&#9670;&nbsp;</a></span>rt_system_scheduler_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_system_scheduler_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize the system scheduler. </p>

</div>
</div>
<a id="ga9aa8a561e0caf5e13126834c4f4bb681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aa8a561e0caf5e13126834c4f4bb681">&#9670;&nbsp;</a></span>rt_system_scheduler_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_system_scheduler_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will startup the scheduler. It will select one thread with the highest priority level, then switch to it. </p>
<p>legacy rt_cpus_lock. some bsp codes still use it as for it's critical region. Since scheduler is never touching this, here we just release it on the entry.</p>
<p>for the accessing of the scheduler context. Noted that we don't have current_thread at this point</p>

</div>
</div>
<a id="gae9f99bb5e2e2032b10ddda7a03eefe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9f99bb5e2e2032b10ddda7a03eefe24">&#9670;&nbsp;</a></span>rt_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_schedule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will perform one scheduling. It will select one thread with the highest priority level in global ready queue or local ready queue, then switch to it. </p>
<dl class="section note"><dt>Note</dt><dd>this function is implemented in both scheduler_up.c and scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="gabb4158a39c5ea956a96b22190ce0ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb4158a39c5ea956a96b22190ce0ed89">&#9670;&nbsp;</a></span>rt_scheduler_do_irq_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_scheduler_do_irq_switch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a scheduling is needed after an IRQ context switching. If yes, it will select one thread with the highest priority level, and then switch to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>is the context to be switched to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is only implemented in scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="gac4c796a7c2031213d9d2416c6e4a5b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c796a7c2031213d9d2416c6e4a5b6a">&#9670;&nbsp;</a></span>rt_enter_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_enter_critical </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will lock the thread scheduler. </p>
<dl class="section note"><dt>Note</dt><dd>this function is implemented in both scheduler_up.c and scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="ga35c56c2d56e2bb0f2df95abc752143df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35c56c2d56e2bb0f2df95abc752143df">&#9670;&nbsp;</a></span>rt_exit_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_exit_critical </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will unlock the thread scheduler. </p>
<dl class="section note"><dt>Note</dt><dd>this function is implemented in both scheduler_up.c and scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="gaf3f894e8efadefda238a5e5ab45c7e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3f894e8efadefda238a5e5ab45c7e21">&#9670;&nbsp;</a></span>rt_critical_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_uint16_t rt_critical_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scheduler lock level. </p>
<dl class="section return"><dt>Returns</dt><dd>the level of the scheduler lock. 0 means unlocked.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function is implemented in both scheduler_up.c and scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="ga268d9fc914d7f4b144568e5de5049b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga268d9fc914d7f4b144568e5de5049b63">&#9670;&nbsp;</a></span>rt_scheduler_ipi_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_scheduler_ipi_handler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will handle IPI interrupt and do a scheduling in system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>is the number of IPI interrupt for system scheduling.</td></tr>
    <tr><td class="paramname">param</td><td>is not used, and can be set to RT_NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function should be invoke or register as ISR in BSP.</dd>
<dd>
this function is only implemented in scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="gae3b532499fffe26f36b7ed8b9e3e4654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3b532499fffe26f36b7ed8b9e3e4654">&#9670;&nbsp;</a></span>rt_schedule_insert_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_schedule_insert_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__thread.html">rt_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will insert a thread to the system ready queue. The state of thread will be set as READY and the thread will be removed from suspend queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Please do not invoke this function in user application.</dd>
<dd>
this function is implemented in both scheduler_up.c and scheduler_mp.c. </dd></dl>

</div>
</div>
<a id="ga11893d937cb7c879abb12f8bfa4be164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11893d937cb7c879abb12f8bfa4be164">&#9670;&nbsp;</a></span>rt_schedule_remove_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_schedule_remove_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__thread.html">rt_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will remove a thread from system ready queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>is the thread to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Please do not invoke this function in user application.</dd>
<dd>
this function is implemented in both scheduler_up.c and scheduler_mp.c. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Sep 30 2024 16:22:28 for RT-Thread RTOS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
