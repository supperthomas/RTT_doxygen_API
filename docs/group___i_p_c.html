<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RT-Thread RTOS: Inter-Thread Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtthread_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RT-Thread RTOS
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">An open source embedded real-time operating system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___i_p_c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Inter-Thread Communication<div class="ingroups"><a class="el" href="group___kernel.html">RT-Thread Kernel API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Inter-Thread Communication:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="group___i_p_c.png" border="0" usemap="#agroup______i__p__c" alt=""/></div>
<map name="agroup______i__p__c" id="agroup______i__p__c">
<area shape="rect" href="group___kernel.html" title=" " alt="" coords="5,104,161,129"/>
<area shape="rect" title="inter&#45;thread communication" alt="" coords="209,104,417,129"/>
<area shape="rect" href="group__messagequeue.html" title=" " alt="" coords="465,5,585,31"/>
<area shape="rect" href="group__event.html" title=" " alt="" coords="496,55,555,80"/>
<area shape="rect" href="group__semaphore.html" title=" " alt="" coords="477,104,573,129"/>
<area shape="rect" href="group__mutex.html" title=" " alt="" coords="494,153,557,179"/>
<area shape="rect" href="group__mailbox.html" title=" " alt="" coords="488,203,563,228"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__semaphore"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html">Semaphore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mutex"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html">Mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__event"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html">Event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mailbox"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html">Mailbox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__messagequeue"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__messagequeue.html">Messagequeue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__ipc__object.html">rt_ipc_object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__semaphore.html">rt_semaphore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__mutex.html">rt_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__mailbox.html">rt_mailbox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__messagequeue.html">rt_messagequeue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1b618f6714ea8f49a45ea4d105aaf5d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga1b618f6714ea8f49a45ea4d105aaf5d5">RT_IPC_FLAG_FIFO</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga1b618f6714ea8f49a45ea4d105aaf5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296aeeb69fe2c8c5012e1059df4364a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga296aeeb69fe2c8c5012e1059df4364a6">RT_IPC_FLAG_PRIO</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga296aeeb69fe2c8c5012e1059df4364a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ea862e2d1edce01e015bdffe49d586"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gae7ea862e2d1edce01e015bdffe49d586">RT_IPC_CMD_UNKNOWN</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gae7ea862e2d1edce01e015bdffe49d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947606ce2a31a2d70e287c38a09dab3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga947606ce2a31a2d70e287c38a09dab3b">RT_IPC_CMD_RESET</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga947606ce2a31a2d70e287c38a09dab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abbc7b6ef67ffd2825a5679e51a7ea7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga8abbc7b6ef67ffd2825a5679e51a7ea7">RT_IPC_CMD_GET_STATE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga8abbc7b6ef67ffd2825a5679e51a7ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef62ee333f6c34dfe91737568d1c310"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gadef62ee333f6c34dfe91737568d1c310">RT_IPC_CMD_SET_VLIMIT</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:gadef62ee333f6c34dfe91737568d1c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923d8e409f9daa8843978d6805ebcdeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga923d8e409f9daa8843978d6805ebcdeb">RT_WAITING_FOREVER</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:ga923d8e409f9daa8843978d6805ebcdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a487898fe750a9f7e9c37911fbe7cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga78a487898fe750a9f7e9c37911fbe7cb">RT_WAITING_NO</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga78a487898fe750a9f7e9c37911fbe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449614d0024ade7e81e53462bce12a60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga449614d0024ade7e81e53462bce12a60">RT_EVENT_FLAG_AND</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga449614d0024ade7e81e53462bce12a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1685d2d8ef3af705fdc297405eda02ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga1685d2d8ef3af705fdc297405eda02ba">RT_EVENT_FLAG_OR</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga1685d2d8ef3af705fdc297405eda02ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c42d6c619445f9151e76c3242ef052"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gaf1c42d6c619445f9151e76c3242ef052">RT_EVENT_FLAG_CLEAR</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gaf1c42d6c619445f9151e76c3242ef052"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6b174ad0c6281b177865e9452b7f9a71"><td class="memItemLeft" align="right" valign="top">rt_inline rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga6b174ad0c6281b177865e9452b7f9a71">_ipc_object_init</a> (struct <a class="el" href="structrt__ipc__object.html">rt_ipc_object</a> *ipc)</td></tr>
<tr class="separator:ga6b174ad0c6281b177865e9452b7f9a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb76b2b1161287a7be42f2478d500e6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrt__thread.html">rt_thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gadcb76b2b1161287a7be42f2478d500e6">rt_susp_list_dequeue</a> (<a class="el" href="structrt__list__node.html">rt_list_t</a> *susp_list, rt_err_t thread_error)</td></tr>
<tr class="separator:gadcb76b2b1161287a7be42f2478d500e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f20344c3dd0c5b468a22d03be40458"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga47f20344c3dd0c5b468a22d03be40458">rt_susp_list_resume_all</a> (<a class="el" href="structrt__list__node.html">rt_list_t</a> *susp_list, rt_err_t thread_error)</td></tr>
<tr class="separator:ga47f20344c3dd0c5b468a22d03be40458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d699e6dc7d4de6b2613de11791619f3"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga3d699e6dc7d4de6b2613de11791619f3">rt_susp_list_resume_all_irq</a> (<a class="el" href="structrt__list__node.html">rt_list_t</a> *susp_list, rt_err_t thread_error, struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock)</td></tr>
<tr class="separator:ga3d699e6dc7d4de6b2613de11791619f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeac06fe647458b336572c4e6464c30d"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gadeac06fe647458b336572c4e6464c30d">rt_susp_list_enqueue</a> (<a class="el" href="structrt__list__node.html">rt_list_t</a> *susp_list, <a class="el" href="structrt__thread.html">rt_thread_t</a> thread, int ipc_flags)</td></tr>
<tr class="separator:gadeac06fe647458b336572c4e6464c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d606cce2b6cd26472b812d88db85000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga8d606cce2b6cd26472b812d88db85000">rt_susp_list_print</a> (<a class="el" href="structrt__list__node.html">rt_list_t</a> *list)</td></tr>
<tr class="separator:ga8d606cce2b6cd26472b812d88db85000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e560062d5e4b929ad2868e4ccc90f2"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga41e560062d5e4b929ad2868e4ccc90f2">rt_thread_suspend_to_list</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread, <a class="el" href="structrt__list__node.html">rt_list_t</a> *susp_list, int ipc_flags, int suspend_flag)</td></tr>
<tr class="separator:ga41e560062d5e4b929ad2868e4ccc90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023e00dd1ae86ddbeb2dbf92771e17ea"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga023e00dd1ae86ddbeb2dbf92771e17ea">rt_sem_init</a> (<a class="el" href="structrt__semaphore.html">rt_sem_t</a> sem, const char *name, rt_uint32_t value, rt_uint8_t flag)</td></tr>
<tr class="separator:ga023e00dd1ae86ddbeb2dbf92771e17ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd3560a50be21e132c71f622870c500"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga7dd3560a50be21e132c71f622870c500">rt_sem_detach</a> (<a class="el" href="structrt__semaphore.html">rt_sem_t</a> sem)</td></tr>
<tr class="separator:ga7dd3560a50be21e132c71f622870c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a4960ff4a173f1d1c35ede42e1227f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga61a4960ff4a173f1d1c35ede42e1227f">rt_sem_create</a> (const char *name, rt_uint32_t value, rt_uint8_t flag)</td></tr>
<tr class="separator:ga61a4960ff4a173f1d1c35ede42e1227f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e45d2b96aab649832b6756d68629bbe"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga0e45d2b96aab649832b6756d68629bbe">rt_sem_delete</a> (<a class="el" href="structrt__semaphore.html">rt_sem_t</a> sem)</td></tr>
<tr class="separator:ga0e45d2b96aab649832b6756d68629bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24da991e29df68a49062d89b95c7de5"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gaf24da991e29df68a49062d89b95c7de5">rt_sem_trytake</a> (<a class="el" href="structrt__semaphore.html">rt_sem_t</a> sem)</td></tr>
<tr class="separator:gaf24da991e29df68a49062d89b95c7de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a5760bc4c7faeb08a7d9c112506f76"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gad9a5760bc4c7faeb08a7d9c112506f76">rt_sem_release</a> (<a class="el" href="structrt__semaphore.html">rt_sem_t</a> sem)</td></tr>
<tr class="separator:gad9a5760bc4c7faeb08a7d9c112506f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569a571566b70682422a8fc5bd53f06f"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga569a571566b70682422a8fc5bd53f06f">rt_sem_control</a> (<a class="el" href="structrt__semaphore.html">rt_sem_t</a> sem, int cmd, void *arg)</td></tr>
<tr class="separator:ga569a571566b70682422a8fc5bd53f06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c29e470fff8981a976ec7f9bb0546e"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga90c29e470fff8981a976ec7f9bb0546e">rt_mutex_init</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex, const char *name, rt_uint8_t flag)</td></tr>
<tr class="separator:ga90c29e470fff8981a976ec7f9bb0546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8b48c0e6884e2c22d08e9e7e98a613"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga7a8b48c0e6884e2c22d08e9e7e98a613">rt_mutex_detach</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:ga7a8b48c0e6884e2c22d08e9e7e98a613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce96ed48d83086aab6ecadebac6d0c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga5ce96ed48d83086aab6ecadebac6d0c6">rt_mutex_create</a> (const char *name, rt_uint8_t flag)</td></tr>
<tr class="separator:ga5ce96ed48d83086aab6ecadebac6d0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a74f51362fc566500bec135599dd5a9"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga8a74f51362fc566500bec135599dd5a9">rt_mutex_delete</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:ga8a74f51362fc566500bec135599dd5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca03f1e5607cda3f739aff4048b8372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga8ca03f1e5607cda3f739aff4048b8372">rt_mutex_drop_thread</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex, <a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga8ca03f1e5607cda3f739aff4048b8372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbba080eb21d82b3877d6e439bdfd28"><td class="memItemLeft" align="right" valign="top">rt_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga7dbba080eb21d82b3877d6e439bdfd28">rt_mutex_setprioceiling</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex, rt_uint8_t priority)</td></tr>
<tr class="separator:ga7dbba080eb21d82b3877d6e439bdfd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef430f1dbc50af1098589232fb54508c"><td class="memItemLeft" align="right" valign="top">rt_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gaef430f1dbc50af1098589232fb54508c">rt_mutex_getprioceiling</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:gaef430f1dbc50af1098589232fb54508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada983d7f4521fdb0f7a5cf6d0a1ac800"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gada983d7f4521fdb0f7a5cf6d0a1ac800">rt_mutex_trytake</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:gada983d7f4521fdb0f7a5cf6d0a1ac800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49c2ee6dc578e6687919f01a4ac5137"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gad49c2ee6dc578e6687919f01a4ac5137">rt_mutex_release</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:gad49c2ee6dc578e6687919f01a4ac5137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e12cce5d8252dd3cc764ba00d429ae9"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga1e12cce5d8252dd3cc764ba00d429ae9">rt_mutex_control</a> (<a class="el" href="structrt__mutex.html">rt_mutex_t</a> mutex, int cmd, void *arg)</td></tr>
<tr class="separator:ga1e12cce5d8252dd3cc764ba00d429ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fad38227b1ebd616a807a09f2eb772"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gab0fad38227b1ebd616a807a09f2eb772">rt_event_init</a> (rt_event_t event, const char *name, rt_uint8_t flag)</td></tr>
<tr class="separator:gab0fad38227b1ebd616a807a09f2eb772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f0b137c7e6d5c2152f6b1d39b57616"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga43f0b137c7e6d5c2152f6b1d39b57616">rt_event_detach</a> (rt_event_t event)</td></tr>
<tr class="separator:ga43f0b137c7e6d5c2152f6b1d39b57616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d752d98e73c0adcdd2b0df24e67efdb"><td class="memItemLeft" align="right" valign="top">rt_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga3d752d98e73c0adcdd2b0df24e67efdb">rt_event_create</a> (const char *name, rt_uint8_t flag)</td></tr>
<tr class="separator:ga3d752d98e73c0adcdd2b0df24e67efdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840d6210713f186fe248a032a68d5e6d"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga840d6210713f186fe248a032a68d5e6d">rt_event_delete</a> (rt_event_t event)</td></tr>
<tr class="separator:ga840d6210713f186fe248a032a68d5e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92efdf32aaf073d733f3bafd02d730e5"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga92efdf32aaf073d733f3bafd02d730e5">rt_event_send</a> (rt_event_t event, rt_uint32_t set)</td></tr>
<tr class="separator:ga92efdf32aaf073d733f3bafd02d730e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aeb964ccccdde76bb5e247c0a913fea"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga3aeb964ccccdde76bb5e247c0a913fea">rt_event_control</a> (rt_event_t event, int cmd, void *arg)</td></tr>
<tr class="separator:ga3aeb964ccccdde76bb5e247c0a913fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05bd0c179f754c32f83a7b013e8953b"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gac05bd0c179f754c32f83a7b013e8953b">rt_mb_init</a> (<a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> mb, const char *name, void *msgpool, rt_size_t size, rt_uint8_t flag)</td></tr>
<tr class="separator:gac05bd0c179f754c32f83a7b013e8953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3312c6094d9c21af33a74f444a8c5993"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga3312c6094d9c21af33a74f444a8c5993">rt_mb_detach</a> (<a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> mb)</td></tr>
<tr class="separator:ga3312c6094d9c21af33a74f444a8c5993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7719d644b6f58399894dec1c6353ac37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga7719d644b6f58399894dec1c6353ac37">rt_mb_create</a> (const char *name, rt_size_t size, rt_uint8_t flag)</td></tr>
<tr class="separator:ga7719d644b6f58399894dec1c6353ac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e9e49401cbbed83515ace6fa13c27b"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga71e9e49401cbbed83515ace6fa13c27b">rt_mb_delete</a> (<a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> mb)</td></tr>
<tr class="separator:ga71e9e49401cbbed83515ace6fa13c27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b0d532eab2989b713fdb0b1fac6665"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gac2b0d532eab2989b713fdb0b1fac6665">rt_mb_send</a> (<a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> mb, rt_ubase_t value)</td></tr>
<tr class="separator:gac2b0d532eab2989b713fdb0b1fac6665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9da3320cdbeee5aa86e65cdf48f928"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gabc9da3320cdbeee5aa86e65cdf48f928">rt_mb_urgent</a> (<a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> mb, rt_ubase_t value)</td></tr>
<tr class="separator:gabc9da3320cdbeee5aa86e65cdf48f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c381ffe3aab6dea429c98ecfcea44c"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga18c381ffe3aab6dea429c98ecfcea44c">rt_mb_control</a> (<a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> mb, int cmd, void *arg)</td></tr>
<tr class="separator:ga18c381ffe3aab6dea429c98ecfcea44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5b76df894964c908271ab0951f7e86"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gaac5b76df894964c908271ab0951f7e86">rt_mq_init</a> (<a class="el" href="structrt__messagequeue.html">rt_mq_t</a> mq, const char *name, void *msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag)</td></tr>
<tr class="separator:gaac5b76df894964c908271ab0951f7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed6238494fac3ab081a90d9c563a8f3"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga1ed6238494fac3ab081a90d9c563a8f3">rt_mq_detach</a> (<a class="el" href="structrt__messagequeue.html">rt_mq_t</a> mq)</td></tr>
<tr class="separator:ga1ed6238494fac3ab081a90d9c563a8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35acff654ecee2a76d5555e9683d8470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga35acff654ecee2a76d5555e9683d8470">rt_mq_create</a> (const char *name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag)</td></tr>
<tr class="separator:ga35acff654ecee2a76d5555e9683d8470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf0bfedc6677ca8357d8b345c9026c9"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gacbf0bfedc6677ca8357d8b345c9026c9">rt_mq_delete</a> (<a class="el" href="structrt__messagequeue.html">rt_mq_t</a> mq)</td></tr>
<tr class="separator:gacbf0bfedc6677ca8357d8b345c9026c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d128f328e2e979f0ee86d633937e4e"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gab3d128f328e2e979f0ee86d633937e4e">rt_mq_send</a> (<a class="el" href="structrt__messagequeue.html">rt_mq_t</a> mq, const void *buffer, rt_size_t size)</td></tr>
<tr class="separator:gab3d128f328e2e979f0ee86d633937e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb1abee716f2f5c24a36aff2ffd32c75"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#gafb1abee716f2f5c24a36aff2ffd32c75">rt_mq_urgent</a> (<a class="el" href="structrt__messagequeue.html">rt_mq_t</a> mq, const void *buffer, rt_size_t size)</td></tr>
<tr class="separator:gafb1abee716f2f5c24a36aff2ffd32c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1ec7b2bfbc8029b0200755505d7c55"><td class="memItemLeft" align="right" valign="top">rt_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga3b1ec7b2bfbc8029b0200755505d7c55">rt_mq_control</a> (<a class="el" href="structrt__messagequeue.html">rt_mq_t</a> mq, int cmd, void *arg)</td></tr>
<tr class="separator:ga3b1ec7b2bfbc8029b0200755505d7c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e32f5a4ae6b0da7771e08b061eba1ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga0e32f5a4ae6b0da7771e08b061eba1ee">rt_thread_defunct_enqueue</a> (<a class="el" href="structrt__thread.html">rt_thread_t</a> thread)</td></tr>
<tr class="separator:ga0e32f5a4ae6b0da7771e08b061eba1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f8bcf6aa8d872a07261a8faaa026ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c.html#ga35f8bcf6aa8d872a07261a8faaa026ba">rt_thread_defunct_dequeue</a> (void)</td></tr>
<tr class="separator:ga35f8bcf6aa8d872a07261a8faaa026ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>inter-thread communication </p>
<p>RT-Thread operating system supports the traditional semaphore and mutex.</p><ul>
<li>Mutex objects use inherited priority to prevent priority reversion.</li>
<li>The semaphore release action is safe for interrupt service routine.</li>
</ul>
<p>Moreover, the blocked queue for thread to obtain semaphore or mutex can be sorted by priority or FIFO. There are two flags to indicate this mechanism.</p><ul>
<li>RT_IPC_FLAG_FIFO when the resource is available, thread pended on this resource at first would get the resource.</li>
<li>RT_IPC_FLAG_PRIO when the resource is available, thread pended on this resource who had the most high priority would get the resource.</li>
</ul>
<p>RT-Thread operating systems supports event/fast event, mail box and message queue.</p><ul>
<li>The event mechanism is used to awake a thread by setting one or more corresponding bit of a binary number when an event ocurs.</li>
<li>The fast event supports event thread queue. Once a one bit event occurs, the corresponding blocked thread can be found out timing accurately, then will be waked up.</li>
<li>In mailbox, the mail length is fixed to 4 byte, which is more effective than message queue.</li>
<li>The send action for communication facilities is also safe for interrupt service routine. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1b618f6714ea8f49a45ea4d105aaf5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b618f6714ea8f49a45ea4d105aaf5d5">&#9670;&nbsp;</a></span>RT_IPC_FLAG_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_IPC_FLAG_FIFO&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IPC flags and control command definitions FIFOed IPC. <a class="el" href="group___i_p_c.html">Inter-Thread Communication</a>. </p>

</div>
</div>
<a id="ga296aeeb69fe2c8c5012e1059df4364a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga296aeeb69fe2c8c5012e1059df4364a6">&#9670;&nbsp;</a></span>RT_IPC_FLAG_PRIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_IPC_FLAG_PRIO&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PRIOed IPC. <a class="el" href="group___i_p_c.html">Inter-Thread Communication</a>. </p>

</div>
</div>
<a id="gae7ea862e2d1edce01e015bdffe49d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ea862e2d1edce01e015bdffe49d586">&#9670;&nbsp;</a></span>RT_IPC_CMD_UNKNOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_IPC_CMD_UNKNOWN&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>unknown IPC command </p>

</div>
</div>
<a id="ga947606ce2a31a2d70e287c38a09dab3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga947606ce2a31a2d70e287c38a09dab3b">&#9670;&nbsp;</a></span>RT_IPC_CMD_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_IPC_CMD_RESET&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>reset IPC object </p>

</div>
</div>
<a id="ga8abbc7b6ef67ffd2825a5679e51a7ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8abbc7b6ef67ffd2825a5679e51a7ea7">&#9670;&nbsp;</a></span>RT_IPC_CMD_GET_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_IPC_CMD_GET_STATE&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get the state of IPC object </p>

</div>
</div>
<a id="gadef62ee333f6c34dfe91737568d1c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadef62ee333f6c34dfe91737568d1c310">&#9670;&nbsp;</a></span>RT_IPC_CMD_SET_VLIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_IPC_CMD_SET_VLIMIT&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set max limit value of IPC value </p>

</div>
</div>
<a id="ga923d8e409f9daa8843978d6805ebcdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga923d8e409f9daa8843978d6805ebcdeb">&#9670;&nbsp;</a></span>RT_WAITING_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_WAITING_FOREVER&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block forever until get resource. </p>

</div>
</div>
<a id="ga78a487898fe750a9f7e9c37911fbe7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a487898fe750a9f7e9c37911fbe7cb">&#9670;&nbsp;</a></span>RT_WAITING_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_WAITING_NO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-block. </p>

</div>
</div>
<a id="ga449614d0024ade7e81e53462bce12a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449614d0024ade7e81e53462bce12a60">&#9670;&nbsp;</a></span>RT_EVENT_FLAG_AND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_EVENT_FLAG_AND&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flag definitions in event logic and </p>

</div>
</div>
<a id="ga1685d2d8ef3af705fdc297405eda02ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1685d2d8ef3af705fdc297405eda02ba">&#9670;&nbsp;</a></span>RT_EVENT_FLAG_OR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_EVENT_FLAG_OR&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>logic or </p>

</div>
</div>
<a id="gaf1c42d6c619445f9151e76c3242ef052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c42d6c619445f9151e76c3242ef052">&#9670;&nbsp;</a></span>RT_EVENT_FLAG_CLEAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RT_EVENT_FLAG_CLEAR&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clear flag </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6b174ad0c6281b177865e9452b7f9a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b174ad0c6281b177865e9452b7f9a71">&#9670;&nbsp;</a></span>_ipc_object_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_inline rt_err_t _ipc_object_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__ipc__object.html">rt_ipc_object</a> *&#160;</td>
          <td class="paramname"><em>ipc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize an IPC object, such as semaphore, mutex, messagequeue and mailbox. </p>
<dl class="section note"><dt>Note</dt><dd>Executing this function will complete an initialization of the suspend thread list of the ipc object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipc</td><td>is a pointer to the IPC object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. When the return value is any other values, it means the initialization failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can be called from all IPC initialization and creation. </dd></dl>

</div>
</div>
<a id="gadcb76b2b1161287a7be42f2478d500e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb76b2b1161287a7be42f2478d500e6">&#9670;&nbsp;</a></span>rt_susp_list_dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrt__thread.html">rt_thread</a> * rt_susp_list_dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>susp_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_err_t&#160;</td>
          <td class="paramname"><em>thread_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue a thread from suspended list and set it to ready. The 2 are taken as an atomic operation, so if a thread is returned, it's resumed by us, not any other threads or async events. This is useful if a consumer may be resumed by timeout, signals... besides its producer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">susp_list</td><td>the list thread dequeued from. RT_NULL if no list. </td></tr>
    <tr><td class="paramname">thread_error</td><td>thread error number of the resuming thread. A negative value in this set will be discarded, and thread error will not be changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>struct <a class="el" href="structrt__thread.html">rt_thread</a> * RT_NULL if failed, otherwise the thread resumed </dd></dl>

</div>
</div>
<a id="ga47f20344c3dd0c5b468a22d03be40458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f20344c3dd0c5b468a22d03be40458">&#9670;&nbsp;</a></span>rt_susp_list_resume_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_susp_list_resume_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>susp_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_err_t&#160;</td>
          <td class="paramname"><em>thread_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will resume all suspended threads in the IPC object list, including the suspended list of IPC object, and private list of mailbox etc. </p>
<dl class="section note"><dt>Note</dt><dd>This function will resume all threads in the IPC object list. By contrast, the rt_ipc_list_resume() function will resume a suspended thread in the list of a IPC object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">susp_list</td><td>is a pointer to a suspended thread list of the IPC object. </td></tr>
    <tr><td class="paramname">thread_error</td><td>thread error number of the resuming thread. A negative value in this set will be discarded, and thread error will not be changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the function is successfully executed. When the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="ga3d699e6dc7d4de6b2613de11791619f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d699e6dc7d4de6b2613de11791619f3">&#9670;&nbsp;</a></span>rt_susp_list_resume_all_irq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_susp_list_resume_all_irq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>susp_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_err_t&#160;</td>
          <td class="paramname"><em>thread_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will resume all suspended threads in the IPC object list, including the suspended list of IPC object, and private list of mailbox etc. A lock is passing and hold while operating. </p>
<dl class="section note"><dt>Note</dt><dd>This function will resume all threads in the IPC object list. By contrast, the rt_ipc_list_resume() function will resume a suspended thread in the list of a IPC object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">susp_list</td><td>is a pointer to a suspended thread list of the IPC object. </td></tr>
    <tr><td class="paramname">thread_error</td><td>thread error number of the resuming thread. A negative value in this set will be discarded, and thread error will not be changed. </td></tr>
    <tr><td class="paramname">lock</td><td>the lock to be held while operating susp_list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the function is successfully executed. When the return value is any other values, it means this operation failed. </dd></dl>

</div>
</div>
<a id="gadeac06fe647458b336572c4e6464c30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeac06fe647458b336572c4e6464c30d">&#9670;&nbsp;</a></span>rt_susp_list_enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_susp_list_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>susp_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ipc_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a thread to the suspend list. </p>
<dl class="section note"><dt>Note</dt><dd>Caller must hold the scheduler lock</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">susp_list</td><td>the list thread enqueued to </td></tr>
    <tr><td class="paramname">thread</td><td>the suspended thread </td></tr>
    <tr><td class="paramname">ipc_flags</td><td>the pattern of suspend list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RT_EOK on succeed, otherwise a failure </dd></dl>

</div>
</div>
<a id="ga8d606cce2b6cd26472b812d88db85000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d606cce2b6cd26472b812d88db85000">&#9670;&nbsp;</a></span>rt_susp_list_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_susp_list_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print thread on suspend list to system console. </p>
<p>Suspend list - A basic building block for IPC primitives which interacts with scheduler directly. Its API is similar to a FIFO list.</p>
<p>Note: don't use in application codes directly </p>

</div>
</div>
<a id="ga41e560062d5e4b929ad2868e4ccc90f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e560062d5e4b929ad2868e4ccc90f2">&#9670;&nbsp;</a></span>rt_thread_suspend_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_thread_suspend_to_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__list__node.html">rt_list_t</a> *&#160;</td>
          <td class="paramname"><em>susp_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ipc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>suspend_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will suspend the specified thread and change it to suspend state. </p>
<dl class="section note"><dt>Note</dt><dd>This function ONLY can suspend current thread itself. rt_thread_suspend(rt_thread_self());</dd></dl>
<p>Do not use the rt_thread_suspend to suspend other threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while sharing a resouce with other threads and occupying this resouce, starvation can occur very easily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to be suspended. </td></tr>
    <tr><td class="paramname">susp_list</td><td>the list thread enqueued to. RT_NULL if no list. </td></tr>
    <tr><td class="paramname">ipc_flags</td><td>is a flag for the thread object to be suspended. It determines how the thread is suspended. The flag can be ONE of the following values: RT_IPC_FLAG_PRIO The pending threads will queue in order of priority. RT_IPC_FLAG_FIFO The pending threads will queue in the first-in-first-out method (also known as first-come-first-served (FCFS) scheduling strategy). NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about the first-in-first-out principle, and you clearly understand that all threads involved in this semaphore will become non-real-time threads. </td></tr>
    <tr><td class="paramname">suspend_flag</td><td>status flag of the thread to be suspended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. If the return value is RT_EOK, the function is successfully executed. If the return value is any other values, it means this operation failed. </dd></dl>
<p>enqueue thread on the push list before leaving critical region of scheduler, so we won't miss notification of async events.</p>

</div>
</div>
<a id="ga023e00dd1ae86ddbeb2dbf92771e17ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023e00dd1ae86ddbeb2dbf92771e17ea">&#9670;&nbsp;</a></span>rt_sem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_sem_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize a static semaphore object. </p>
<dl class="section note"><dt>Note</dt><dd>For the static semaphore object, its memory space is allocated by the compiler during compiling, and shall placed on the read-write data segment or on the uninitialized data segment. By contrast, the <a class="el" href="group__semaphore.html#ga61a4960ff4a173f1d1c35ede42e1227f" title="Creating a semaphore object.">rt_sem_create()</a> function will allocate memory space automatically and initialize the semaphore.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__semaphore.html#ga61a4960ff4a173f1d1c35ede42e1227f" title="Creating a semaphore object.">rt_sem_create()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>is a pointer to the semaphore to initialize. It is assumed that storage for the semaphore will be allocated in your application.</td></tr>
    <tr><td class="paramname">name</td><td>is a pointer to the name you would like to give the semaphore.</td></tr>
    <tr><td class="paramname">value</td><td>is the initial value for the semaphore. If used to share resources, you should initialize the value as the number of available resources. If used to signal the occurrence of an event, you should initialize the value as 0.</td></tr>
    <tr><td class="paramname">flag</td><td>is the semaphore flag, which determines the queuing way of how multiple threads wait when the semaphore is not available. The semaphore flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this semaphore will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it represents the initialization failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga7dd3560a50be21e132c71f622870c500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dd3560a50be21e132c71f622870c500">&#9670;&nbsp;</a></span>rt_sem_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_sem_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will detach a static semaphore object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to detach a static semaphore object which is initialized by <a class="el" href="group__semaphore.html#ga023e00dd1ae86ddbeb2dbf92771e17ea" title="This function will initialize a static semaphore object.">rt_sem_init()</a> function. By contrast, the <a class="el" href="group__semaphore.html#ga0e45d2b96aab649832b6756d68629bbe" title="This function will delete a semaphore object and release the memory space.">rt_sem_delete()</a> function will delete a semaphore object. When the semaphore is successfully detached, it will resume all suspended threads in the semaphore list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__semaphore.html#ga0e45d2b96aab649832b6756d68629bbe" title="This function will delete a semaphore object and release the memory space.">rt_sem_delete()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>is a pointer to a semaphore object to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it means that the semaphore detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY detach a static semaphore initialized by the <a class="el" href="group__semaphore.html#ga023e00dd1ae86ddbeb2dbf92771e17ea" title="This function will initialize a static semaphore object.">rt_sem_init()</a> function. If the semaphore is created by the <a class="el" href="group__semaphore.html#ga61a4960ff4a173f1d1c35ede42e1227f" title="Creating a semaphore object.">rt_sem_create()</a> function, you MUST NOT USE this function to detach it, ONLY USE the <a class="el" href="group__semaphore.html#ga0e45d2b96aab649832b6756d68629bbe" title="This function will delete a semaphore object and release the memory space.">rt_sem_delete()</a> function to complete the deletion. </dd></dl>

</div>
</div>
<a id="ga61a4960ff4a173f1d1c35ede42e1227f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a4960ff4a173f1d1c35ede42e1227f">&#9670;&nbsp;</a></span>rt_sem_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__semaphore.html">rt_sem_t</a> rt_sem_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creating a semaphore object. </p>
<dl class="section note"><dt>Note</dt><dd>For the semaphore object, its memory space is allocated automatically. By contrast, the <a class="el" href="group__semaphore.html#ga023e00dd1ae86ddbeb2dbf92771e17ea" title="This function will initialize a static semaphore object.">rt_sem_init()</a> function will initialize a static semaphore object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__semaphore.html#ga023e00dd1ae86ddbeb2dbf92771e17ea" title="This function will initialize a static semaphore object.">rt_sem_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a pointer to the name you would like to give the semaphore.</td></tr>
    <tr><td class="paramname">value</td><td>is the initial value for the semaphore. If used to share resources, you should initialize the value as the number of available resources. If used to signal the occurrence of an event, you should initialize the value as 0.</td></tr>
    <tr><td class="paramname">flag</td><td>is the semaphore flag, which determines the queuing way of how multiple threads wait when the semaphore is not available. The semaphore flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this semaphore will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the semaphore object. When the return value is RT_NULL, it means the creation failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can NOT be called in interrupt context. You can use macor RT_DEBUG_NOT_IN_INTERRUPT to check it. </dd></dl>

</div>
</div>
<a id="ga0e45d2b96aab649832b6756d68629bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e45d2b96aab649832b6756d68629bbe">&#9670;&nbsp;</a></span>rt_sem_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_sem_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will delete a semaphore object and release the memory space. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to delete a semaphore object which is created by the <a class="el" href="group__semaphore.html#ga61a4960ff4a173f1d1c35ede42e1227f" title="Creating a semaphore object.">rt_sem_create()</a> function. By contrast, the <a class="el" href="group__semaphore.html#ga7dd3560a50be21e132c71f622870c500" title="This function will detach a static semaphore object.">rt_sem_detach()</a> function will detach a static semaphore object. When the semaphore is successfully deleted, it will resume all suspended threads in the semaphore list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__semaphore.html#ga7dd3560a50be21e132c71f622870c500" title="This function will detach a static semaphore object.">rt_sem_detach()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>is a pointer to a semaphore object to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the semaphore detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY delete a semaphore initialized by the <a class="el" href="group__semaphore.html#ga61a4960ff4a173f1d1c35ede42e1227f" title="Creating a semaphore object.">rt_sem_create()</a> function. If the semaphore is initialized by the <a class="el" href="group__semaphore.html#ga023e00dd1ae86ddbeb2dbf92771e17ea" title="This function will initialize a static semaphore object.">rt_sem_init()</a> function, you MUST NOT USE this function to delete it, ONLY USE the <a class="el" href="group__semaphore.html#ga7dd3560a50be21e132c71f622870c500" title="This function will detach a static semaphore object.">rt_sem_detach()</a> function to complete the detachment. </dd></dl>

</div>
</div>
<a id="gaf24da991e29df68a49062d89b95c7de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf24da991e29df68a49062d89b95c7de5">&#9670;&nbsp;</a></span>rt_sem_trytake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_sem_trytake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will try to take a semaphore, if the semaphore is unavailable, the thread returns immediately. </p>
<dl class="section note"><dt>Note</dt><dd>This function is very similar to the rt_sem_take() function, when the semaphore is not available, the <a class="el" href="group__semaphore.html#gaf24da991e29df68a49062d89b95c7de5" title="This function will try to take a semaphore, if the semaphore is unavailable, the thread returns immed...">rt_sem_trytake()</a> function will return immediately without waiting for a timeout. In other words, rt_sem_trytake(sem) has the same effect as rt_sem_take(sem, 0).</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rt_sem_take()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>is a pointer to a semaphore object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. ONLY When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the semaphore take failed. </dd></dl>

</div>
</div>
<a id="gad9a5760bc4c7faeb08a7d9c112506f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9a5760bc4c7faeb08a7d9c112506f76">&#9670;&nbsp;</a></span>rt_sem_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_sem_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will release a semaphore. If there is thread suspended on the semaphore, it will get resumed. </p>
<dl class="section note"><dt>Note</dt><dd>If there are threads suspended on this semaphore, the first thread in the list of this semaphore object will be resumed, and a thread scheduling (rt_schedule) will be executed. If no threads are suspended on this semaphore, the count value sem-&gt;value of this semaphore will increase by 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>is a pointer to a semaphore object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the semaphore release failed. </dd></dl>

</div>
</div>
<a id="ga569a571566b70682422a8fc5bd53f06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga569a571566b70682422a8fc5bd53f06f">&#9670;&nbsp;</a></span>rt_sem_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_sem_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__semaphore.html">rt_sem_t</a>&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set some extra attributions of a semaphore object. </p>
<dl class="section note"><dt>Note</dt><dd>Currently this function only supports the RT_IPC_CMD_RESET command to reset the semaphore.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>is a pointer to a semaphore object.</td></tr>
    <tr><td class="paramname">cmd</td><td>is a command word used to configure some attributions of the semaphore.</td></tr>
    <tr><td class="paramname">arg</td><td>is the argument of the function to execute the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that this function failed to execute. </dd></dl>

</div>
</div>
<a id="ga90c29e470fff8981a976ec7f9bb0546e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90c29e470fff8981a976ec7f9bb0546e">&#9670;&nbsp;</a></span>rt_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a static mutex object. </p>
<dl class="section note"><dt>Note</dt><dd>For the static mutex object, its memory space is allocated by the compiler during compiling, and shall placed on the read-write data segment or on the uninitialized data segment. By contrast, the <a class="el" href="group__mutex.html#ga5ce96ed48d83086aab6ecadebac6d0c6" title="This function will create a mutex object.">rt_mutex_create()</a> function will automatically allocate memory space and initialize the mutex.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mutex.html#ga5ce96ed48d83086aab6ecadebac6d0c6" title="This function will create a mutex object.">rt_mutex_create()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to the mutex to initialize. It is assumed that storage for the mutex will be allocated in your application.</td></tr>
    <tr><td class="paramname">name</td><td>is a pointer to the name that given to the mutex.</td></tr>
    <tr><td class="paramname">flag</td><td>is the mutex flag, which determines the queuing way of how multiple threads wait when the mutex is not available. NOTE: This parameter has been obsoleted. It can be RT_IPC_FLAG_PRIO, RT_IPC_FLAG_FIFO or RT_NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it represents the initialization failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga7a8b48c0e6884e2c22d08e9e7e98a613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8b48c0e6884e2c22d08e9e7e98a613">&#9670;&nbsp;</a></span>rt_mutex_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mutex_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will detach a static mutex object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to detach a static mutex object which is initialized by <a class="el" href="group__mutex.html#ga90c29e470fff8981a976ec7f9bb0546e" title="Initialize a static mutex object.">rt_mutex_init()</a> function. By contrast, the <a class="el" href="group__mutex.html#ga8a74f51362fc566500bec135599dd5a9" title="This function will delete a mutex object and release this memory space.">rt_mutex_delete()</a> function will delete a mutex object. When the mutex is successfully detached, it will resume all suspended threads in the mutex list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mutex.html#ga8a74f51362fc566500bec135599dd5a9" title="This function will delete a mutex object and release this memory space.">rt_mutex_delete()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it means that the mutex detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY detach a static mutex initialized by the <a class="el" href="group__mutex.html#ga90c29e470fff8981a976ec7f9bb0546e" title="Initialize a static mutex object.">rt_mutex_init()</a> function. If the mutex is created by the <a class="el" href="group__mutex.html#ga5ce96ed48d83086aab6ecadebac6d0c6" title="This function will create a mutex object.">rt_mutex_create()</a> function, you MUST NOT USE this function to detach it, ONLY USE the <a class="el" href="group__mutex.html#ga8a74f51362fc566500bec135599dd5a9" title="This function will delete a mutex object and release this memory space.">rt_mutex_delete()</a> function to complete the deletion. </dd></dl>

</div>
</div>
<a id="ga5ce96ed48d83086aab6ecadebac6d0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce96ed48d83086aab6ecadebac6d0c6">&#9670;&nbsp;</a></span>rt_mutex_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__mutex.html">rt_mutex_t</a> rt_mutex_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will create a mutex object. </p>
<dl class="section note"><dt>Note</dt><dd>For the mutex object, its memory space is automatically allocated. By contrast, the <a class="el" href="group__mutex.html#ga90c29e470fff8981a976ec7f9bb0546e" title="Initialize a static mutex object.">rt_mutex_init()</a> function will initialize a static mutex object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mutex.html#ga90c29e470fff8981a976ec7f9bb0546e" title="Initialize a static mutex object.">rt_mutex_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a pointer to the name that given to the mutex.</td></tr>
    <tr><td class="paramname">flag</td><td>is the mutex flag, which determines the queuing way of how multiple threads wait when the mutex is not available. NOTE: This parameter has been obsoleted. It can be RT_IPC_FLAG_PRIO, RT_IPC_FLAG_FIFO or RT_NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the mutex object. When the return value is RT_NULL, it means the creation failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga8a74f51362fc566500bec135599dd5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a74f51362fc566500bec135599dd5a9">&#9670;&nbsp;</a></span>rt_mutex_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mutex_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will delete a mutex object and release this memory space. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to delete a mutex object which is created by the <a class="el" href="group__mutex.html#ga5ce96ed48d83086aab6ecadebac6d0c6" title="This function will create a mutex object.">rt_mutex_create()</a> function. By contrast, the <a class="el" href="group__mutex.html#ga7a8b48c0e6884e2c22d08e9e7e98a613" title="This function will detach a static mutex object.">rt_mutex_detach()</a> function will detach a static mutex object. When the mutex is successfully deleted, it will resume all suspended threads in the mutex list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mutex.html#ga7a8b48c0e6884e2c22d08e9e7e98a613" title="This function will detach a static mutex object.">rt_mutex_detach()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mutex detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY delete a mutex initialized by the <a class="el" href="group__mutex.html#ga5ce96ed48d83086aab6ecadebac6d0c6" title="This function will create a mutex object.">rt_mutex_create()</a> function. If the mutex is initialized by the <a class="el" href="group__mutex.html#ga90c29e470fff8981a976ec7f9bb0546e" title="Initialize a static mutex object.">rt_mutex_init()</a> function, you MUST NOT USE this function to delete it, ONLY USE the <a class="el" href="group__mutex.html#ga7a8b48c0e6884e2c22d08e9e7e98a613" title="This function will detach a static mutex object.">rt_mutex_detach()</a> function to complete the detachment. </dd></dl>

</div>
</div>
<a id="ga8ca03f1e5607cda3f739aff4048b8372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca03f1e5607cda3f739aff4048b8372">&#9670;&nbsp;</a></span>rt_mutex_drop_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_mutex_drop_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>drop a thread from the suspend list of mutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object. </td></tr>
    <tr><td class="paramname">thread</td><td>is the thread should be dropped from mutex. </td></tr>
  </table>
  </dd>
</dl>
<p>Should change the priority of mutex owner thread Note: After current thread is detached from mutex pending list, there is a chance that the mutex owner has been released the mutex. Which means mutex-&gt;owner can be NULL at this point. If that happened, it had already reset its priority. So it's okay to skip</p>

</div>
</div>
<a id="ga7dbba080eb21d82b3877d6e439bdfd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dbba080eb21d82b3877d6e439bdfd28">&#9670;&nbsp;</a></span>rt_mutex_setprioceiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_uint8_t rt_mutex_setprioceiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the prioceiling attribute of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object. </td></tr>
    <tr><td class="paramname">priority</td><td>is the priority should be set to mutex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the old priority ceiling </dd></dl>

</div>
</div>
<a id="gaef430f1dbc50af1098589232fb54508c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef430f1dbc50af1098589232fb54508c">&#9670;&nbsp;</a></span>rt_mutex_getprioceiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_uint8_t rt_mutex_getprioceiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the prioceiling attribute of the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the current priority ceiling of the mutex. </dd></dl>

</div>
</div>
<a id="gada983d7f4521fdb0f7a5cf6d0a1ac800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada983d7f4521fdb0f7a5cf6d0a1ac800">&#9670;&nbsp;</a></span>rt_mutex_trytake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mutex_trytake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will try to take a mutex, if the mutex is unavailable, the thread returns immediately. </p>
<dl class="section note"><dt>Note</dt><dd>This function is very similar to the rt_mutex_take() function, when the mutex is not available, except that <a class="el" href="group__mutex.html#gada983d7f4521fdb0f7a5cf6d0a1ac800" title="This function will try to take a mutex, if the mutex is unavailable, the thread returns immediately.">rt_mutex_trytake()</a> will return immediately without waiting for a timeout when the mutex is not available. In other words, rt_mutex_trytake(mutex) has the same effect as rt_mutex_take(mutex, 0).</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rt_mutex_take()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. ONLY When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mutex take failed. </dd></dl>

</div>
</div>
<a id="gad49c2ee6dc578e6687919f01a4ac5137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49c2ee6dc578e6687919f01a4ac5137">&#9670;&nbsp;</a></span>rt_mutex_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mutex_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will release a mutex. If there is thread suspended on the mutex, the thread will be resumed. </p>
<dl class="section note"><dt>Note</dt><dd>If there are threads suspended on this mutex, the first thread in the list of this mutex object will be resumed, and a thread scheduling (rt_schedule) will be executed. If no threads are suspended on this mutex, the count value mutex-&gt;value of this mutex will increase by 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mutex release failed. </dd></dl>
<p>a timeout timer had triggered while we try. So we skip this thread and try again.</p>

</div>
</div>
<a id="ga1e12cce5d8252dd3cc764ba00d429ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e12cce5d8252dd3cc764ba00d429ae9">&#9670;&nbsp;</a></span>rt_mutex_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mutex_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mutex.html">rt_mutex_t</a>&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set some extra attributions of a mutex object. </p>
<dl class="section note"><dt>Note</dt><dd>Currently this function does not implement the control function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>is a pointer to a mutex object.</td></tr>
    <tr><td class="paramname">cmd</td><td>is a command word used to configure some attributions of the mutex.</td></tr>
    <tr><td class="paramname">arg</td><td>is the argument of the function to execute the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that this function failed to execute. </dd></dl>

</div>
</div>
<a id="gab0fad38227b1ebd616a807a09f2eb772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0fad38227b1ebd616a807a09f2eb772">&#9670;&nbsp;</a></span>rt_event_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_event_init </td>
          <td>(</td>
          <td class="paramtype">rt_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function will initialize a static event object. </p>
<dl class="section note"><dt>Note</dt><dd>For the static event object, its memory space is allocated by the compiler during compiling, and shall placed on the read-write data segment or on the uninitialized data segment. By contrast, the <a class="el" href="group__event.html#ga3d752d98e73c0adcdd2b0df24e67efdb" title="Creating an event object.">rt_event_create()</a> function will allocate memory space automatically and initialize the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event.html#ga3d752d98e73c0adcdd2b0df24e67efdb" title="Creating an event object.">rt_event_create()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>is a pointer to the event to initialize. It is assumed that storage for the event will be allocated in your application.</td></tr>
    <tr><td class="paramname">name</td><td>is a pointer to the name that given to the event.</td></tr>
    <tr><td class="paramname">flag</td><td>is the event flag, which determines the queuing way of how multiple threads wait when the event is not available. The event flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this event will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it represents the initialization failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga43f0b137c7e6d5c2152f6b1d39b57616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43f0b137c7e6d5c2152f6b1d39b57616">&#9670;&nbsp;</a></span>rt_event_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_event_detach </td>
          <td>(</td>
          <td class="paramtype">rt_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will detach a static event object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to detach a static event object which is initialized by <a class="el" href="group__event.html#gab0fad38227b1ebd616a807a09f2eb772" title="The function will initialize a static event object.">rt_event_init()</a> function. By contrast, the <a class="el" href="group__event.html#ga840d6210713f186fe248a032a68d5e6d" title="This function will delete an event object and release the memory space.">rt_event_delete()</a> function will delete an event object. When the event is successfully detached, it will resume all suspended threads in the event list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event.html#ga840d6210713f186fe248a032a68d5e6d" title="This function will delete an event object and release the memory space.">rt_event_delete()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>is a pointer to an event object to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it means that the event detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY detach a static event initialized by the <a class="el" href="group__event.html#gab0fad38227b1ebd616a807a09f2eb772" title="The function will initialize a static event object.">rt_event_init()</a> function. If the event is created by the <a class="el" href="group__event.html#ga3d752d98e73c0adcdd2b0df24e67efdb" title="Creating an event object.">rt_event_create()</a> function, you MUST NOT USE this function to detach it, ONLY USE the <a class="el" href="group__event.html#ga840d6210713f186fe248a032a68d5e6d" title="This function will delete an event object and release the memory space.">rt_event_delete()</a> function to complete the deletion. </dd></dl>

</div>
</div>
<a id="ga3d752d98e73c0adcdd2b0df24e67efdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d752d98e73c0adcdd2b0df24e67efdb">&#9670;&nbsp;</a></span>rt_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_event_t rt_event_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creating an event object. </p>
<dl class="section note"><dt>Note</dt><dd>For the event object, its memory space is allocated automatically. By contrast, the <a class="el" href="group__event.html#gab0fad38227b1ebd616a807a09f2eb772" title="The function will initialize a static event object.">rt_event_init()</a> function will initialize a static event object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event.html#gab0fad38227b1ebd616a807a09f2eb772" title="The function will initialize a static event object.">rt_event_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a pointer to the name that given to the event.</td></tr>
    <tr><td class="paramname">flag</td><td>is the event flag, which determines the queuing way of how multiple threads wait when the event is not available. The event flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this event will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the event object. When the return value is RT_NULL, it means the creation failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga840d6210713f186fe248a032a68d5e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga840d6210713f186fe248a032a68d5e6d">&#9670;&nbsp;</a></span>rt_event_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_event_delete </td>
          <td>(</td>
          <td class="paramtype">rt_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will delete an event object and release the memory space. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to delete an event object which is created by the <a class="el" href="group__event.html#ga3d752d98e73c0adcdd2b0df24e67efdb" title="Creating an event object.">rt_event_create()</a> function. By contrast, the <a class="el" href="group__event.html#ga43f0b137c7e6d5c2152f6b1d39b57616" title="This function will detach a static event object.">rt_event_detach()</a> function will detach a static event object. When the event is successfully deleted, it will resume all suspended threads in the event list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event.html#ga43f0b137c7e6d5c2152f6b1d39b57616" title="This function will detach a static event object.">rt_event_detach()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>is a pointer to an event object to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the event detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY delete an event initialized by the <a class="el" href="group__event.html#ga3d752d98e73c0adcdd2b0df24e67efdb" title="Creating an event object.">rt_event_create()</a> function. If the event is initialized by the <a class="el" href="group__event.html#gab0fad38227b1ebd616a807a09f2eb772" title="The function will initialize a static event object.">rt_event_init()</a> function, you MUST NOT USE this function to delete it, ONLY USE the <a class="el" href="group__event.html#ga43f0b137c7e6d5c2152f6b1d39b57616" title="This function will detach a static event object.">rt_event_detach()</a> function to complete the detachment. </dd></dl>

</div>
</div>
<a id="ga92efdf32aaf073d733f3bafd02d730e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92efdf32aaf073d733f3bafd02d730e5">&#9670;&nbsp;</a></span>rt_event_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_event_send </td>
          <td>(</td>
          <td class="paramtype">rt_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint32_t&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will send an event to the event object. If there is a thread suspended on the event, the thread will be resumed. </p>
<dl class="section note"><dt>Note</dt><dd>When using this function, you need to use the parameter (set) to specify the event flag of the event object, then the function will traverse the list of suspended threads waiting on the event object. If there is a thread suspended on the event, and the thread's event_info and the event flag of the current event object matches, the thread will be resumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>is a pointer to the event object to be sent.</td></tr>
    <tr><td class="paramname">set</td><td>is a flag that you will set for this event's flag. You can set an event flag, or you can set multiple flags through OR logic operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the event detach failed. </dd></dl>

</div>
</div>
<a id="ga3aeb964ccccdde76bb5e247c0a913fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aeb964ccccdde76bb5e247c0a913fea">&#9670;&nbsp;</a></span>rt_event_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_event_control </td>
          <td>(</td>
          <td class="paramtype">rt_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set some extra attributions of an event object. </p>
<dl class="section note"><dt>Note</dt><dd>Currently this function only supports the RT_IPC_CMD_RESET command to reset the event.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>is a pointer to an event object.</td></tr>
    <tr><td class="paramname">cmd</td><td>is a command word used to configure some attributions of the event.</td></tr>
    <tr><td class="paramname">arg</td><td>is the argument of the function to execute the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that this function failed to execute. </dd></dl>

</div>
</div>
<a id="gac05bd0c179f754c32f83a7b013e8953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac05bd0c179f754c32f83a7b013e8953b">&#9670;&nbsp;</a></span>rt_mb_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mb_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msgpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a static mailbox object. </p>
<dl class="section note"><dt>Note</dt><dd>For the static mailbox object, its memory space is allocated by the compiler during compiling, and shall placed on the read-write data segment or on the uninitialized data segment. By contrast, the <a class="el" href="group__mailbox.html#ga7719d644b6f58399894dec1c6353ac37" title="Creating a mailbox object.">rt_mb_create()</a> function will allocate memory space automatically and initialize the mailbox.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mailbox.html#ga7719d644b6f58399894dec1c6353ac37" title="Creating a mailbox object.">rt_mb_create()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>is a pointer to the mailbox to initialize. It is assumed that storage for the mailbox will be allocated in your application.</td></tr>
    <tr><td class="paramname">name</td><td>is a pointer to the name that given to the mailbox.</td></tr>
    <tr><td class="paramname">msgpool</td><td>the begin address of buffer to save received mail.</td></tr>
    <tr><td class="paramname">size</td><td>is the maximum number of mails in the mailbox. For example, when the mailbox buffer capacity is N, size is N/4.</td></tr>
    <tr><td class="paramname">flag</td><td>is the mailbox flag, which determines the queuing way of how multiple threads wait when the mailbox is not available. The mailbox flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                        (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this mailbox will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it represents the initialization failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga3312c6094d9c21af33a74f444a8c5993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3312c6094d9c21af33a74f444a8c5993">&#9670;&nbsp;</a></span>rt_mb_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mb_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will detach a static mailbox object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to detach a static mailbox object which is initialized by <a class="el" href="group__mailbox.html#gac05bd0c179f754c32f83a7b013e8953b" title="Initialize a static mailbox object.">rt_mb_init()</a> function. By contrast, the <a class="el" href="group__mailbox.html#ga71e9e49401cbbed83515ace6fa13c27b" title="This function will delete a mailbox object and release the memory space.">rt_mb_delete()</a> function will delete a mailbox object. When the mailbox is successfully detached, it will resume all suspended threads in the mailbox list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mailbox.html#ga71e9e49401cbbed83515ace6fa13c27b" title="This function will delete a mailbox object and release the memory space.">rt_mb_delete()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>is a pointer to a mailbox object to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it means that the mailbox detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY detach a static mailbox initialized by the <a class="el" href="group__mailbox.html#gac05bd0c179f754c32f83a7b013e8953b" title="Initialize a static mailbox object.">rt_mb_init()</a> function. If the mailbox is created by the <a class="el" href="group__mailbox.html#ga7719d644b6f58399894dec1c6353ac37" title="Creating a mailbox object.">rt_mb_create()</a> function, you MUST NOT USE this function to detach it, ONLY USE the <a class="el" href="group__mailbox.html#ga71e9e49401cbbed83515ace6fa13c27b" title="This function will delete a mailbox object and release the memory space.">rt_mb_delete()</a> function to complete the deletion. </dd></dl>

</div>
</div>
<a id="ga7719d644b6f58399894dec1c6353ac37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7719d644b6f58399894dec1c6353ac37">&#9670;&nbsp;</a></span>rt_mb_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a> rt_mb_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creating a mailbox object. </p>
<dl class="section note"><dt>Note</dt><dd>For the mailbox object, its memory space is allocated automatically. By contrast, the <a class="el" href="group__mailbox.html#gac05bd0c179f754c32f83a7b013e8953b" title="Initialize a static mailbox object.">rt_mb_init()</a> function will initialize a static mailbox object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mailbox.html#gac05bd0c179f754c32f83a7b013e8953b" title="Initialize a static mailbox object.">rt_mb_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a pointer that given to the mailbox.</td></tr>
    <tr><td class="paramname">size</td><td>is the maximum number of mails in the mailbox. For example, when mailbox buffer capacity is N, size is N/4.</td></tr>
    <tr><td class="paramname">flag</td><td>is the mailbox flag, which determines the queuing way of how multiple threads wait when the mailbox is not available. The mailbox flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this mailbox will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the mailbox object. When the return value is RT_NULL, it means the creation failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga71e9e49401cbbed83515ace6fa13c27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71e9e49401cbbed83515ace6fa13c27b">&#9670;&nbsp;</a></span>rt_mb_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mb_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will delete a mailbox object and release the memory space. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to delete a mailbox object which is created by the <a class="el" href="group__mailbox.html#ga7719d644b6f58399894dec1c6353ac37" title="Creating a mailbox object.">rt_mb_create()</a> function. By contrast, the <a class="el" href="group__mailbox.html#ga3312c6094d9c21af33a74f444a8c5993" title="This function will detach a static mailbox object.">rt_mb_detach()</a> function will detach a static mailbox object. When the mailbox is successfully deleted, it will resume all suspended threads in the mailbox list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mailbox.html#ga3312c6094d9c21af33a74f444a8c5993" title="This function will detach a static mailbox object.">rt_mb_detach()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>is a pointer to a mailbox object to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mailbox detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can only delete mailbox created by the <a class="el" href="group__mailbox.html#ga7719d644b6f58399894dec1c6353ac37" title="Creating a mailbox object.">rt_mb_create()</a> function. If the mailbox is initialized by the <a class="el" href="group__mailbox.html#gac05bd0c179f754c32f83a7b013e8953b" title="Initialize a static mailbox object.">rt_mb_init()</a> function, you MUST NOT USE this function to delete it, ONLY USE the <a class="el" href="group__mailbox.html#ga3312c6094d9c21af33a74f444a8c5993" title="This function will detach a static mailbox object.">rt_mb_detach()</a> function to complete the detachment. </dd></dl>

</div>
</div>
<a id="gac2b0d532eab2989b713fdb0b1fac6665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2b0d532eab2989b713fdb0b1fac6665">&#9670;&nbsp;</a></span>rt_mb_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mb_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_ubase_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will send an mail to the mailbox object. If there is a thread suspended on the mailbox, the thread will be resumed. </p>
<dl class="section note"><dt>Note</dt><dd>When using this function to send a mail, if the mailbox is fully used, this function will return an error code immediately without waiting time. By contrast, the rt_mb_send_wait() function is set a timeout to wait for the mail to be sent.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rt_mb_send_wait()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>is a pointer to the mailbox object to be sent.</td></tr>
    <tr><td class="paramname">value</td><td>is a value to the content of the mail you want to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mailbox detach failed. </dd></dl>

</div>
</div>
<a id="gabc9da3320cdbeee5aa86e65cdf48f928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc9da3320cdbeee5aa86e65cdf48f928">&#9670;&nbsp;</a></span>rt_mb_urgent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mb_urgent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_ubase_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will send an urgent mail to the mailbox object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is almost the same as the <a class="el" href="group__mailbox.html#gac2b0d532eab2989b713fdb0b1fac6665" title="This function will send an mail to the mailbox object. If there is a thread suspended on the mailbox,...">rt_mb_send()</a> function. The only difference is that when sending an urgent mail, the mail will be placed at the head of the mail queue so that the recipient can receive the urgent mail first.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mailbox.html#gac2b0d532eab2989b713fdb0b1fac6665" title="This function will send an mail to the mailbox object. If there is a thread suspended on the mailbox,...">rt_mb_send()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>is a pointer to the mailbox object to be sent.</td></tr>
    <tr><td class="paramname">value</td><td>is the content of the mail you want to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mailbox detach failed. </dd></dl>

</div>
</div>
<a id="ga18c381ffe3aab6dea429c98ecfcea44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c381ffe3aab6dea429c98ecfcea44c">&#9670;&nbsp;</a></span>rt_mb_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mb_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__mailbox.html">rt_mailbox_t</a>&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set some extra attributions of a mailbox object. </p>
<dl class="section note"><dt>Note</dt><dd>Currently this function only supports the RT_IPC_CMD_RESET command to reset the mailbox.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>is a pointer to a mailbox object.</td></tr>
    <tr><td class="paramname">cmd</td><td>is a command used to configure some attributions of the mailbox.</td></tr>
    <tr><td class="paramname">arg</td><td>is the argument of the function to execute the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that this function failed to execute. </dd></dl>

</div>
</div>
<a id="gaac5b76df894964c908271ab0951f7e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5b76df894964c908271ab0951f7e86">&#9670;&nbsp;</a></span>rt_mq_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mq_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td>
          <td class="paramname"><em>mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msgpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>msg_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>pool_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a static messagequeue object. </p>
<dl class="section note"><dt>Note</dt><dd>For the static messagequeue object, its memory space is allocated by the compiler during compiling, and shall placed on the read-write data segment or on the uninitialized data segment. By contrast, the <a class="el" href="group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470" title="Creating a messagequeue object.">rt_mq_create()</a> function will allocate memory space automatically and initialize the messagequeue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470" title="Creating a messagequeue object.">rt_mq_create()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>is a pointer to the messagequeue to initialize. It is assumed that storage for the messagequeue will be allocated in your application.</td></tr>
    <tr><td class="paramname">name</td><td>is a pointer to the name that given to the messagequeue.</td></tr>
    <tr><td class="paramname">msgpool</td><td>is a pointer to the starting address of the memory space you allocated for the messagequeue in advance. In other words, msgpool is a pointer to the messagequeue buffer of the starting address.</td></tr>
    <tr><td class="paramname">msg_size</td><td>is the maximum length of a message in the messagequeue (Unit: Byte).</td></tr>
    <tr><td class="paramname">pool_size</td><td>is the size of the memory space allocated for the messagequeue in advance.</td></tr>
    <tr><td class="paramname">flag</td><td>is the messagequeue flag, which determines the queuing way of how multiple threads wait when the messagequeue is not available. The messagequeue flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this messagequeue will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it represents the initialization failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY be called from threads. </dd></dl>

</div>
</div>
<a id="ga1ed6238494fac3ab081a90d9c563a8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed6238494fac3ab081a90d9c563a8f3">&#9670;&nbsp;</a></span>rt_mq_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mq_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td>
          <td class="paramname"><em>mq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will detach a static messagequeue object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to detach a static messagequeue object which is initialized by <a class="el" href="group__messagequeue.html#gaac5b76df894964c908271ab0951f7e86" title="Initialize a static messagequeue object.">rt_mq_init()</a> function. By contrast, the <a class="el" href="group__messagequeue.html#gacbf0bfedc6677ca8357d8b345c9026c9" title="This function will delete a messagequeue object and release the memory.">rt_mq_delete()</a> function will delete a messagequeue object. When the messagequeue is successfully detached, it will resume all suspended threads in the messagequeue list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__messagequeue.html#gacbf0bfedc6677ca8357d8b345c9026c9" title="This function will delete a messagequeue object and release the memory.">rt_mq_delete()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>is a pointer to a messagequeue object to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the initialization is successful. If the return value is any other values, it means that the messagequeue detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY detach a static messagequeue initialized by the <a class="el" href="group__messagequeue.html#gaac5b76df894964c908271ab0951f7e86" title="Initialize a static messagequeue object.">rt_mq_init()</a> function. If the messagequeue is created by the <a class="el" href="group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470" title="Creating a messagequeue object.">rt_mq_create()</a> function, you MUST NOT USE this function to detach it, and ONLY USE the <a class="el" href="group__messagequeue.html#gacbf0bfedc6677ca8357d8b345c9026c9" title="This function will delete a messagequeue object and release the memory.">rt_mq_delete()</a> function to complete the deletion. </dd></dl>

</div>
</div>
<a id="ga35acff654ecee2a76d5555e9683d8470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35acff654ecee2a76d5555e9683d8470">&#9670;&nbsp;</a></span>rt_mq_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a> rt_mq_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>msg_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>max_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_uint8_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creating a messagequeue object. </p>
<dl class="section note"><dt>Note</dt><dd>For the messagequeue object, its memory space is allocated automatically. By contrast, the <a class="el" href="group__messagequeue.html#gaac5b76df894964c908271ab0951f7e86" title="Initialize a static messagequeue object.">rt_mq_init()</a> function will initialize a static messagequeue object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__messagequeue.html#gaac5b76df894964c908271ab0951f7e86" title="Initialize a static messagequeue object.">rt_mq_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a pointer that given to the messagequeue.</td></tr>
    <tr><td class="paramname">msg_size</td><td>is the maximum length of a message in the messagequeue (Unit: Byte).</td></tr>
    <tr><td class="paramname">max_msgs</td><td>is the maximum number of messages in the messagequeue.</td></tr>
    <tr><td class="paramname">flag</td><td>is the messagequeue flag, which determines the queuing way of how multiple threads wait when the messagequeue is not available. The messagequeue flag can be ONE of the following values: <pre class="fragment">RT_IPC_FLAG_PRIO          The pending threads will queue in order of priority.

RT_IPC_FLAG_FIFO          The pending threads will queue in the first-in-first-out method
                          (also known as first-come-first-served (FCFS) scheduling strategy).

NOTE: RT_IPC_FLAG_FIFO is a non-real-time scheduling mode. It is strongly recommended to
use RT_IPC_FLAG_PRIO to ensure the thread is real-time UNLESS your applications concern about
the first-in-first-out principle, and you clearly understand that all threads involved in
this messagequeue will become non-real-time threads.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the messagequeue object. When the return value is RT_NULL, it means the creation failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can NOT be called in interrupt context. You can use macor RT_DEBUG_NOT_IN_INTERRUPT to check it. </dd></dl>

</div>
</div>
<a id="gacbf0bfedc6677ca8357d8b345c9026c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbf0bfedc6677ca8357d8b345c9026c9">&#9670;&nbsp;</a></span>rt_mq_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mq_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td>
          <td class="paramname"><em>mq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will delete a messagequeue object and release the memory. </p>
<dl class="section note"><dt>Note</dt><dd>This function is used to delete a messagequeue object which is created by the <a class="el" href="group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470" title="Creating a messagequeue object.">rt_mq_create()</a> function. By contrast, the <a class="el" href="group__messagequeue.html#ga1ed6238494fac3ab081a90d9c563a8f3" title="This function will detach a static messagequeue object.">rt_mq_detach()</a> function will detach a static messagequeue object. When the messagequeue is successfully deleted, it will resume all suspended threads in the messagequeue list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__messagequeue.html#ga1ed6238494fac3ab081a90d9c563a8f3" title="This function will detach a static messagequeue object.">rt_mq_detach()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>is a pointer to a messagequeue object to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the messagequeue detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can ONLY delete a messagequeue initialized by the <a class="el" href="group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470" title="Creating a messagequeue object.">rt_mq_create()</a> function. If the messagequeue is initialized by the <a class="el" href="group__messagequeue.html#gaac5b76df894964c908271ab0951f7e86" title="Initialize a static messagequeue object.">rt_mq_init()</a> function, you MUST NOT USE this function to delete it, ONLY USE the <a class="el" href="group__messagequeue.html#ga1ed6238494fac3ab081a90d9c563a8f3" title="This function will detach a static messagequeue object.">rt_mq_detach()</a> function to complete the detachment. for example,the <a class="el" href="group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470" title="Creating a messagequeue object.">rt_mq_create()</a> function, it cannot be called in interrupt context. </dd></dl>

</div>
</div>
<a id="gab3d128f328e2e979f0ee86d633937e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3d128f328e2e979f0ee86d633937e4e">&#9670;&nbsp;</a></span>rt_mq_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mq_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td>
          <td class="paramname"><em>mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will send a message to the messagequeue object. If there is a thread suspended on the messagequeue, the thread will be resumed. </p>
<dl class="section note"><dt>Note</dt><dd>When using this function to send a message, if the messagequeue is fully used, the current thread will wait for a timeout. By contrast, when the messagequeue is fully used, the rt_mq_send_wait() function will return an error code immediately without waiting.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rt_mq_send_wait()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>is a pointer to the messagequeue object to be sent.</td></tr>
    <tr><td class="paramname">buffer</td><td>is the content of the message.</td></tr>
    <tr><td class="paramname">size</td><td>is the length of the message(Unit: Byte).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the messagequeue detach failed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can be called in interrupt context and thread context. </dd></dl>

</div>
</div>
<a id="gafb1abee716f2f5c24a36aff2ffd32c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb1abee716f2f5c24a36aff2ffd32c75">&#9670;&nbsp;</a></span>rt_mq_urgent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mq_urgent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td>
          <td class="paramname"><em>mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will send an urgent message to the messagequeue object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is almost the same as the <a class="el" href="group__messagequeue.html#gab3d128f328e2e979f0ee86d633937e4e" title="This function will send a message to the messagequeue object. If there is a thread suspended on the m...">rt_mq_send()</a> function. The only difference is that when sending an urgent message, the message is placed at the head of the messagequeue so that the recipient can receive the urgent message first.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__messagequeue.html#gab3d128f328e2e979f0ee86d633937e4e" title="This function will send a message to the messagequeue object. If there is a thread suspended on the m...">rt_mq_send()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>is a pointer to the messagequeue object to be sent.</td></tr>
    <tr><td class="paramname">buffer</td><td>is the content of the message.</td></tr>
    <tr><td class="paramname">size</td><td>is the length of the message(Unit: Byte).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that the mailbox detach failed. </dd></dl>

</div>
</div>
<a id="ga3b1ec7b2bfbc8029b0200755505d7c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b1ec7b2bfbc8029b0200755505d7c55">&#9670;&nbsp;</a></span>rt_mq_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_err_t rt_mq_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__messagequeue.html">rt_mq_t</a>&#160;</td>
          <td class="paramname"><em>mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set some extra attributions of a messagequeue object. </p>
<dl class="section note"><dt>Note</dt><dd>Currently this function only supports the RT_IPC_CMD_RESET command to reset the messagequeue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>is a pointer to a messagequeue object.</td></tr>
    <tr><td class="paramname">cmd</td><td>is a command used to configure some attributions of the messagequeue.</td></tr>
    <tr><td class="paramname">arg</td><td>is the argument of the function to execute the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the operation status. When the return value is RT_EOK, the operation is successful. If the return value is any other values, it means that this function failed to execute. </dd></dl>

</div>
</div>
<a id="ga0e32f5a4ae6b0da7771e08b061eba1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e32f5a4ae6b0da7771e08b061eba1ee">&#9670;&nbsp;</a></span>rt_thread_defunct_enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_thread_defunct_enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__thread.html">rt_thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a thread to defunct queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to be enqueued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It must be called between rt_hw_interrupt_disable and rt_hw_interrupt_enable </dd></dl>

</div>
</div>
<a id="ga35f8bcf6aa8d872a07261a8faaa026ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35f8bcf6aa8d872a07261a8faaa026ba">&#9670;&nbsp;</a></span>rt_thread_defunct_dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrt__thread.html">rt_thread_t</a> rt_thread_defunct_dequeue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue a thread from defunct queue. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 30 2024 16:10:33 for RT-Thread RTOS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
